---
// Server-side logic for admin page
import { supabase } from '../lib/supabase';
import { checkAdminAccess, getSessionFromCookies } from '../lib/session';
import LoginModal from '../components/ui/LoginModal.astro';
import AdminAuthRefresh from '../components/AdminAuthRefresh.astro';

// Check if user is already logged in using cookies
const { isAdmin, error: authError } = await checkAdminAccess(Astro.cookies);

if (!isAdmin) {
  // Redirect to login with current URL as redirect parameter
  const currentUrl = Astro.url.pathname + Astro.url.search;
  return Astro.redirect(`/login?redirect=${encodeURIComponent(currentUrl)}`);
}

// Get user info for display - we need to get the session to display user info
const { session } = await getSessionFromCookies(Astro.cookies);
const user = session?.user;

import '../styles/global.css';
import '../styles/admin.css';
import EditEventModal from '../components/ui/EditEventModal.astro';
import AddLocationModal from '../components/ui/AddLocationModal.astro';
import AddOrganizationModal from '../components/ui/AddOrganizationModal.astro';
import EditAnnouncementModal from '../components/ui/EditAnnouncementModal.astro';
import SeriesModal from '../components/ui/SeriesModal.astro';
---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Admin Dashboard - Der Town</title>
  <!-- Material Symbols & Icons Font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
</head>
<body class="font-sans bg-gradient-to-br from-gray-50 to-gray-100 m-0 min-h-screen text-gray-900 leading-relaxed">

<div class="admin-card">
  <div class="header">
    <div class="header-left">
      <a href="/" class="admin-logo-link">
        <img class="admin-logo" src="/logo.svg" alt="Der Town Logo" />
      </a>
      <div class="header-title-section">
        <h1>Admin Dashboard</h1>
        <p>Welcome, {user?.email || 'Admin'}</p>
      </div>
    </div>
    <div class="flex gap-2 items-center">
      <button type="button" onclick="window.openAddLocationModal?.()" class="icon-btn btn-create" aria-label="Add location" style="background: linear-gradient(to bottom right, #059669, #047857);">
        <span class="material-symbols-outlined text-2xl">location_on</span>
        <span class="tooltip">Add location</span>
      </button>
      <button type="button" onclick="window.openAddOrganizationModal?.()" class="icon-btn btn-create" aria-label="Add organization" style="background: linear-gradient(to bottom right, #0d9488, #0f766e);">
        <span class="material-symbols-outlined text-2xl">business</span>
        <span class="tooltip">Add organization</span>
      </button>
      <a href="/admin/events/new" class="icon-btn btn-create" aria-label="Create New Event">
        <span class="material-symbols-outlined text-2xl">event</span>
        <span class="tooltip">Create New Event</span>
      </a>
      <button class="icon-btn btn-create" onclick="openCreateSeriesModal()" aria-label="Create Event Series" style="background: linear-gradient(to bottom right, #9333ea, #7e22ce);">
        <span class="material-symbols-outlined text-2xl">repeat</span>
        <span class="tooltip">Create Event Series</span>
      </button>
      <button class="icon-btn btn-create btn-announcement" onclick="openCreateAnnouncementModal()" aria-label="Create New Announcement">
        <span class="material-symbols-outlined text-2xl">campaign</span>
        <span class="tooltip">Create New Announcement</span>
      </button>
      <button class="icon-btn logout-btn" onclick="logout()" aria-label="Logout">
        <span class="material-symbols-outlined text-2xl">exit_to_app</span>
        <span class="tooltip">Logout</span>
    </button>
    </div>
  </div>

  <nav class="view-all-nav" aria-label="View all content">
    <span class="view-all-label">View all:</span>
    <a href="/admin/locations">Locations</a>
    <span class="view-all-sep" aria-hidden="true">路</span>
    <a href="/admin/organizations">Organizations</a>
    <span class="view-all-sep" aria-hidden="true">路</span>
    <a href="/admin/series">Series</a>
    <span class="view-all-sep" aria-hidden="true">路</span>
    <a href="/admin/events">Events</a>
    <span class="view-all-sep" aria-hidden="true">路</span>
    <a href="/admin/announcements">Announcements</a>
  </nav>

  <div id="message"></div>

  <div id="pending-locations-orgs" class="section hidden">
    <div class="section-header">
      <div class="section-title">
        <span class="material-symbols-outlined">warning</span>
        Pending approval
      </div>
    </div>
    <div class="flex flex-wrap gap-4">
      <a id="pending-locations-link" href="/admin/locations" class="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-amber-100 text-amber-900 hover:bg-amber-200 font-medium">
        <span class="material-symbols-outlined">location_on</span>
        <span id="pending-locations-count">0</span> pending location(s)
      </a>
      <a id="pending-organizations-link" href="/admin/organizations" class="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-amber-100 text-amber-900 hover:bg-amber-200 font-medium">
        <span class="material-symbols-outlined">business</span>
        <span id="pending-organizations-count">0</span> pending organization(s)
      </a>
    </div>
  </div>

  <!-- Modals -->
  <EditEventModal />
  <AddLocationModal />
  <AddOrganizationModal />
  <EditAnnouncementModal />
  <SeriesModal />
  <AdminAuthRefresh />

  <div class="section">
    <div class="section-header">
      <div class="section-title">
        <span class="material-symbols-outlined">pending_actions</span>
        Approve Events
      </div>
    </div>
    <div id="loading" class="loading">Loading events...</div>
    <div id="events-container"></div>
  </div>

  <div class="section">
    <div class="section-title">
      <span class="material-symbols-outlined">warning</span>
      Add Missing Location or Primary Tag to Events
  </div>
    <div id="incomplete-loading" class="loading">Loading incomplete events...</div>
    <div id="incomplete-events-container"></div>
  </div>

  <div class="section">
    <div class="section-header">
      <div class="section-title">
        <span class="material-symbols-outlined">campaign</span>
        Approve Announcements
      </div>
    </div>
    <div id="announcements-loading" class="loading">Loading announcements...</div>
    <div id="announcements-container"></div>
  </div>

  <div class="section">
    <div class="section-header">
      <div class="section-title">
        <span class="material-symbols-outlined">schedule</span>
        Upcoming Announcements
      </div>
    </div>
    <div id="upcoming-announcements-loading" class="loading">Loading upcoming announcements...</div>
    <div id="upcoming-announcements-container"></div>
  </div>
</div>

<!-- Login Modal (for session expiration scenarios) -->
<LoginModal 
  title="Session Expired"
  description="Your session has expired. Please log in again to continue."
  redirectUrl={Astro.url.pathname + Astro.url.search}
  reloadOnSuccess={true}
/>

<script type="module">
  /**
   * Admin Dashboard Client-Side Script
   * 
   * This script handles all client-side interactions for the admin dashboard:
   * - Loading and displaying events and announcements for approval
   * - Editing events and announcements via modals
   * - Approving/rejecting items
   * - Creating new events
   * - Autocomplete functionality for locations, organizations, and parent events
   * 
   * All operations go through server-side API endpoints for security.
   * No Supabase credentials are exposed to the client.
   */
  
  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================
  
  /**
   * Normalizes URLs by adding https:// protocol if missing
   * @param {string|null} url - The URL to normalize
   * @returns {string|null} - Normalized URL or null if input is empty
   */
  function normalizeUrl(url) {
    if (!url || url.trim() === '') return null;
    const trimmed = url.trim();
    // If it already has a protocol (http:// or https://), return as is
    if (/^https?:\/\//i.test(trimmed)) {
      return trimmed;
    }
    // Otherwise, add https://
    return 'https://' + trimmed;
  }

  function getEventStatusFromForm() {
    const cancelled = document.getElementById('editEventCancelled')?.checked;
    if (cancelled) return 'cancelled';
    const draft = document.getElementById('editEventDraft')?.checked;
    return draft ? 'pending' : 'approved';
  }

  function syncEventStatusControls() {
    const cancelledCheckbox = document.getElementById('editEventCancelled');
    const draftCheckbox = document.getElementById('editEventDraft');
    if (!cancelledCheckbox || !draftCheckbox) return;

    if (cancelledCheckbox.checked) {
      draftCheckbox.checked = false;
      draftCheckbox.disabled = true;
    } else {
      draftCheckbox.disabled = false;
    }
  }

  /**
   * Displays a temporary message notification to the user
   * @param {string} message - The message to display
   * @param {string} type - Message type: 'info', 'success', or 'error'
   */
  function showMessage(message, type = 'info') {
    const messageDiv = document.createElement('div');
    messageDiv.textContent = message;
    messageDiv.className = `fixed top-5 right-5 px-5 py-3 rounded text-white font-medium z-[1000] max-w-xs break-words ${
      type === 'error' ? 'bg-red-600' : 
      type === 'success' ? 'bg-green-600' : 
      'bg-blue-600'
    }`;
    
    document.body.appendChild(messageDiv);
    setTimeout(() => {
      if (messageDiv.parentNode) {
        messageDiv.parentNode.removeChild(messageDiv);
      }
    }, 5000);
  }

  // ============================================================================
  // GLOBAL DATA STORES
  // ============================================================================
  
  // Reference data for autocomplete dropdowns
  let allLocations = [];
  let allOrganizations = [];
  let allTags = [];
  let allParentEvents = [];

  // ============================================================================
  // DATA LOADING FUNCTIONS
  // ============================================================================
  
  /**
   * Loads reference data (locations, organizations, tags, parent events) for autocomplete
   */
  async function loadReferenceData() {
    try {
      const [locationsRes, orgsRes, tagsRes, parentEventsRes] = await Promise.all([
        fetch('/api/admin/locations', { credentials: 'include' }),
        fetch('/api/admin/organizations', { credentials: 'include' }),
        fetch('/api/admin/tags', { credentials: 'include' }),
        fetch('/api/admin/parent-events', { credentials: 'include' })
      ]);

      if (!locationsRes.ok) {
        console.error('Failed to load locations:', locationsRes.status, await locationsRes.text());
      } else {
        allLocations = await locationsRes.json();
      }
      
      if (!orgsRes.ok) {
        console.error('Failed to load organizations:', orgsRes.status, await orgsRes.text());
      } else {
        allOrganizations = await orgsRes.json();
      }
      
      if (!tagsRes.ok) {
        console.error('Failed to load tags:', tagsRes.status, await tagsRes.text());
      } else {
        allTags = await tagsRes.json();
        // Populate tag dropdowns for edit event modal
        const primaryTagSelect = document.getElementById('editEventPrimaryTag');
        const secondaryTagSelect = document.getElementById('editEventSecondaryTag');
        if (primaryTagSelect && secondaryTagSelect) {
          allTags.forEach(tag => {
            const option1 = document.createElement('option');
            option1.value = tag.id;
            option1.textContent = tag.name;
            primaryTagSelect.appendChild(option1);
            
            const option2 = document.createElement('option');
            option2.value = tag.id;
            option2.textContent = tag.name;
            secondaryTagSelect.appendChild(option2);
          });
        }
        // Populate tag dropdowns for series modal
        const seriesPrimaryTagSelect = document.getElementById('seriesPrimaryTag');
        const seriesSecondaryTagSelect = document.getElementById('seriesSecondaryTag');
        if (seriesPrimaryTagSelect && seriesSecondaryTagSelect) {
          allTags.forEach(tag => {
            const option1 = document.createElement('option');
            option1.value = tag.id;
            option1.textContent = tag.name;
            seriesPrimaryTagSelect.appendChild(option1);
            
            const option2 = document.createElement('option');
            option2.value = tag.id;
            option2.textContent = tag.name;
            seriesSecondaryTagSelect.appendChild(option2);
          });
        }
      }
      
      if (!parentEventsRes.ok) {
        console.error('Failed to load parent events:', parentEventsRes.status, await parentEventsRes.text());
      } else {
        allParentEvents = await parentEventsRes.json();
      }
    } catch (error) {
      console.error('Error loading reference data:', error);
    }
  }

  // ============================================================================
  // AUTOCOMPLETE SETUP FUNCTIONS
  // ============================================================================
  
  // Track retry attempts to prevent infinite loops
  let autocompleteSetupRetries = {
    location: 0,
    organization: 0,
    announcementOrganization: 0,
    parentEvent: 0
  };
  const MAX_RETRIES = 10;
  
  // Track if autocomplete has been set up to avoid duplicate event listeners
  let autocompleteSetupComplete = {
    location: false,
    organization: false,
    announcementOrganization: false,
    parentEvent: false
  };
  
  /**
   * Re-runs autocomplete setup for event modal (called when modal opens)
   * Resets the completion flags to allow retry if setup failed initially
   */
  function ensureEventAutocompleteSetup() {
    // Reset flags to allow retry if elements weren't found initially
    if (!autocompleteSetupComplete.location) {
      autocompleteSetupRetries.location = 0; // Reset retry counter
      setupLocationAutocomplete();
    }
    if (!autocompleteSetupComplete.organization) {
      autocompleteSetupRetries.organization = 0; // Reset retry counter
      setupOrganizationAutocomplete();
    }
    if (!autocompleteSetupComplete.parentEvent) {
      autocompleteSetupRetries.parentEvent = 0; // Reset retry counter
      setupParentEventAutocomplete();
    }
  }
  
  /**
   * Re-runs autocomplete setup for announcement modal (called when modal opens)
   * Resets the completion flags to allow retry if setup failed initially
   */
  function ensureAnnouncementAutocompleteSetup() {
    // Reset flags to allow retry if elements weren't found initially
    if (!autocompleteSetupComplete.announcementOrganization) {
      autocompleteSetupRetries.announcementOrganization = 0; // Reset retry counter
      setupAnnouncementOrganizationAutocomplete();
    }
  }
  
  /**
   * Sets up autocomplete functionality for location selection in event forms
   */
  function setupLocationAutocomplete() {
    const searchInput = document.getElementById('editEventLocationSearch');
    const hiddenInput = document.getElementById('editEventLocationId');
    const dropdown = document.getElementById('editEventLocationDropdown');

    if (!searchInput || !hiddenInput || !dropdown) {
      if (autocompleteSetupRetries.location < MAX_RETRIES) {
        autocompleteSetupRetries.location++;
        // Retrying location autocomplete setup
        // Retry after a short delay in case modals haven't rendered yet
        setTimeout(setupLocationAutocomplete, 100);
      } else {
        console.error('[AUTOCOMPLETE] Location autocomplete elements not found after retries');
      }
      return;
    }
    autocompleteSetupRetries.location = 0; // Reset on success
    
    // Only set up if not already set up (avoid duplicate listeners)
    if (autocompleteSetupComplete.location) {
      return;
    }
    autocompleteSetupComplete.location = true;

    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase().trim();
      if (query.length === 0) {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
        hiddenInput.value = '';
        return;
      }

      if (!allLocations || !Array.isArray(allLocations)) {
        return;
      }

      const matches = allLocations.filter(loc => 
        loc && loc.name && loc.name.toLowerCase().includes(query)
      ).slice(0, 10);

      if (matches.length === 0) {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
        return;
      }

      dropdown.innerHTML = matches.map(loc => `
        <div class="autocomplete-dropdown-item" 
             onclick="selectLocation('${loc.id}', '${loc.name.replace(/'/g, "\\'")}')">
          ${loc.name}${loc.address ? ` - ${loc.address}` : ''}
        </div>
      `).join('');
      dropdown.classList.remove('hidden');
      dropdown.classList.add('block');
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
      }
    });

    window.selectLocation = function(id, name) {
      searchInput.value = name;
      hiddenInput.value = id;
      dropdown.classList.add('hidden');
      dropdown.classList.remove('block');
    };
  }

  /**
   * Sets up autocomplete functionality for organization selection in event forms
   */
  function setupOrganizationAutocomplete() {
    const searchInput = document.getElementById('editEventOrganizationSearch');
    const hiddenInput = document.getElementById('editEventOrganizationId');
    const dropdown = document.getElementById('editEventOrganizationDropdown');

    if (!searchInput || !hiddenInput || !dropdown) {
      if (autocompleteSetupRetries.organization < MAX_RETRIES) {
        autocompleteSetupRetries.organization++;
        // Retrying organization autocomplete setup
        // Retry after a short delay in case modals haven't rendered yet
        setTimeout(setupOrganizationAutocomplete, 100);
      } else {
        console.error('[AUTOCOMPLETE] Organization autocomplete elements not found after retries');
      }
      return;
    }
    autocompleteSetupRetries.organization = 0; // Reset on success
    
    // Only set up if not already set up (avoid duplicate listeners)
    if (autocompleteSetupComplete.organization) {
      return;
    }
    autocompleteSetupComplete.organization = true;

    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase().trim();
      if (query.length === 0) {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
        hiddenInput.value = '';
        return;
      }

      if (!allOrganizations || !Array.isArray(allOrganizations)) {
        return;
      }

      const matches = allOrganizations.filter(org => 
        org && org.name && org.name.toLowerCase().includes(query)
      ).slice(0, 10);

      if (matches.length === 0) {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
        return;
      }

      dropdown.innerHTML = matches.map(org => `
        <div class="autocomplete-dropdown-item" 
             onclick="selectOrganization('${org.id}', '${org.name.replace(/'/g, "\\'")}')">
          ${org.name}
        </div>
      `).join('');
      dropdown.classList.remove('hidden');
      dropdown.classList.add('block');
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
      }
    });

    window.selectOrganization = function(id, name) {
      searchInput.value = name;
      hiddenInput.value = id;
      dropdown.classList.add('hidden');
      dropdown.classList.remove('block');
    };
  }

  /**
   * Sets up autocomplete functionality for organization selection in announcement forms
   */
  function setupAnnouncementOrganizationAutocomplete() {
    const searchInput = document.getElementById('editAnnouncementOrganizationSearch');
    const hiddenInput = document.getElementById('editAnnouncementOrganizationId');
    const dropdown = document.getElementById('editAnnouncementOrganizationDropdown');
    const newOrgInput = document.getElementById('editAnnouncementOrganizationAdded');

    if (!searchInput || !hiddenInput || !dropdown) {
      if (autocompleteSetupRetries.announcementOrganization < MAX_RETRIES) {
        autocompleteSetupRetries.announcementOrganization++;
        // Retry after a short delay in case modals haven't rendered yet
        setTimeout(setupAnnouncementOrganizationAutocomplete, 100);
      } else {
        console.error('[AUTOCOMPLETE] Announcement organization autocomplete elements not found after retries');
      }
      return;
    }
    autocompleteSetupRetries.announcementOrganization = 0; // Reset on success
    
    // Only set up if not already set up (avoid duplicate listeners)
    if (autocompleteSetupComplete.announcementOrganization) {
      return;
    }
    autocompleteSetupComplete.announcementOrganization = true;

    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase().trim();
      if (query.length === 0) {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
        hiddenInput.value = '';
        return;
      }

      if (!allOrganizations || !Array.isArray(allOrganizations)) {
        return;
      }

      const matches = allOrganizations.filter(org => 
        org && org.name && org.name.toLowerCase().includes(query)
      ).slice(0, 10);

      if (matches.length > 0) {
        dropdown.innerHTML = matches.map(org => `
          <div class="autocomplete-dropdown-item" 
               onclick="selectAnnouncementOrganization('${org.id}', '${org.name.replace(/'/g, "\\'")}')">
            ${org.name}
          </div>
        `).join('');
        dropdown.classList.remove('hidden');
        dropdown.classList.add('block');
      } else {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
      }
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
      }
    });

    window.selectAnnouncementOrganization = function(id, name) {
      searchInput.value = name;
      hiddenInput.value = id;
      dropdown.classList.add('hidden');
      dropdown.classList.remove('block');
      if (newOrgInput) newOrgInput.value = ''; // Clear new organization if existing one selected
    };

    // Clear selection when typing in "add new" field
    if (newOrgInput) {
      newOrgInput.addEventListener('input', () => {
        if (newOrgInput.value.trim()) {
          searchInput.value = '';
          hiddenInput.value = '';
          dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
        }
      });
    }
  }

  /**
   * Sets up autocomplete functionality for parent event selection in event forms
   */
  function setupParentEventAutocomplete() {
    const searchInput = document.getElementById('editEventParentEventSearch');
    const hiddenInput = document.getElementById('editEventParentEventId');
    const dropdown = document.getElementById('editEventParentEventDropdown');

    if (!searchInput || !hiddenInput || !dropdown) {
      if (autocompleteSetupRetries.parentEvent < MAX_RETRIES) {
        autocompleteSetupRetries.parentEvent++;
        // Retry after a short delay in case modals haven't rendered yet
        setTimeout(setupParentEventAutocomplete, 100);
      } else {
        console.error('[AUTOCOMPLETE] Parent event autocomplete elements not found after retries');
      }
      return;
    }
    autocompleteSetupRetries.parentEvent = 0; // Reset on success
    
    // Only set up if not already set up (avoid duplicate listeners)
    if (autocompleteSetupComplete.parentEvent) {
      return;
    }
    autocompleteSetupComplete.parentEvent = true;

    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase().trim();
      if (query.length === 0) {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
        hiddenInput.value = '';
        return;
      }

      if (!allParentEvents || !Array.isArray(allParentEvents)) {
        return;
      }

      const matches = allParentEvents.filter(event => 
        event && event.title && event.title.toLowerCase().includes(query)
      ).slice(0, 10);

      if (matches.length === 0) {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
        return;
      }

      dropdown.innerHTML = matches.map(event => {
        const dateStr = event.start_date ? new Date(event.start_date).toLocaleDateString() : '';
        const timeStr = event.start_time ? event.start_time.substring(0, 5) : '';
        const displayStr = `${event.title}${dateStr ? ` - ${dateStr}` : ''}${timeStr ? ` ${timeStr}` : ''}`;
        return `
          <div class="autocomplete-dropdown-item" 
               onclick="selectParentEvent('${event.id}', '${event.title.replace(/'/g, "\\'")}')">
            ${displayStr}
          </div>
        `;
      }).join('');
      dropdown.classList.remove('hidden');
      dropdown.classList.add('block');
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
        dropdown.classList.add('hidden');
        dropdown.classList.remove('block');
      }
    });

    window.selectParentEvent = function(id, title) {
      searchInput.value = title;
      hiddenInput.value = id;
      dropdown.classList.add('hidden');
      dropdown.classList.remove('block');
    };
  }

  // ============================================================================
  // DATA DISPLAY FUNCTIONS
  // ============================================================================
  
  /**
   * Loads and displays events that need approval (both staged and existing)
   */
  async function loadEventsToApprove() {
    try {
      const loading = document.getElementById('loading');
      // Load both staged and existing events in parallel
      const [stagedResponse, existingResponse] = await Promise.all([
        fetch('/api/admin/events-staged', { credentials: 'include' }),
        fetch('/api/admin/events', { credentials: 'include' })
      ]);

      if (!stagedResponse.ok || !existingResponse.ok) {
        if (stagedResponse.status === 401 || existingResponse.status === 401) {
          if (typeof window.openLoginModal === 'function') {
            window.openLoginModal();
          } else {
            const currentUrl = encodeURIComponent(window.location.pathname + window.location.search);
            window.location.href = `/login?redirect=${currentUrl}`;
          }
            return;
          }
        throw new Error(`HTTP error! status: ${stagedResponse.status || existingResponse.status}`);
      }

      const stagedData = await stagedResponse.json();
      const existingData = await existingResponse.json();
      
      // Combine both arrays, marking staged events
      const stagedEvents = (stagedData.events || []).map(e => ({ ...e, isStaged: true }));
      const existingEvents = (existingData.events || []).map(e => ({ ...e, isStaged: false }));
      const allEvents = [...stagedEvents, ...existingEvents].sort((a, b) => {
        // Sort by start_date, then staged events first
        if (a.start_date !== b.start_date) {
          return (a.start_date || '').localeCompare(b.start_date || '');
        }
        return a.isStaged ? -1 : 1;
      });

      displayEvents(allEvents);
      if (loading) loading.classList.add('hidden');
      } catch (error) {
      const loading = document.getElementById('loading');
      if (loading) loading.classList.add('hidden');
      showMessage('Error loading events: ' + error.message, 'error');
    }
  }

  /**
   * Loads and displays announcements that need approval (both staged and existing)
   */
  async function loadAnnouncementsToApprove() {
    try {
      const loading = document.getElementById('announcements-loading');
      // Load both staged and existing announcements in parallel
      const [stagedResponse, existingResponse] = await Promise.all([
        fetch('/api/admin/announcements-staged', { credentials: 'include' }),
        fetch('/api/admin/announcements', { credentials: 'include' })
      ]);

      if (!stagedResponse.ok || !existingResponse.ok) {
        if (stagedResponse.status === 401 || existingResponse.status === 401) {
          if (typeof window.openLoginModal === 'function') {
            window.openLoginModal();
          } else {
            const currentUrl = encodeURIComponent(window.location.pathname + window.location.search);
            window.location.href = `/login?redirect=${currentUrl}`;
          }
            return;
          }
        throw new Error(`HTTP error! status: ${stagedResponse.status || existingResponse.status}`);
      }

      const stagedData = await stagedResponse.json();
      const existingData = await existingResponse.json();
      
      // Combine both arrays, marking staged announcements
      const stagedAnnouncements = (stagedData.announcements || []).map(a => ({ ...a, isStaged: true }));
      const existingAnnouncements = (existingData.announcements || []).map(a => ({ ...a, isStaged: false }));
      const allAnnouncements = [...stagedAnnouncements, ...existingAnnouncements].sort((a, b) => {
        // Sort by created_at, then staged announcements first
        const aDate = a.created_at || '';
        const bDate = b.created_at || '';
        if (aDate !== bDate) {
          return bDate.localeCompare(aDate); // Most recent first
        }
        return a.isStaged ? -1 : 1;
      });

      displayAnnouncements(allAnnouncements);
      if (loading) loading.classList.add('hidden');
      } catch (error) {
      const loading = document.getElementById('announcements-loading');
      if (loading) loading.classList.add('hidden');
      showMessage('Error loading announcements: ' + error.message, 'error');
      }
    }

  /**
   * Loads and displays upcoming announcements (published announcements scheduled for the future)
   */
  async function loadUpcomingAnnouncements() {
    try {
      const loading = document.getElementById('upcoming-announcements-loading');
      const response = await fetch('/api/admin/announcements/upcoming', { credentials: 'include' });

      if (!response.ok) {
        if (response.status === 401) {
          if (typeof window.openLoginModal === 'function') {
            window.openLoginModal();
          } else {
            const currentUrl = encodeURIComponent(window.location.pathname + window.location.search);
            window.location.href = `/login?redirect=${currentUrl}`;
          }
          return;
        }
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      const announcements = data.announcements || [];
      
      // Display upcoming announcements (read-only view with edit option)
      displayUpcomingAnnouncements(announcements);
      if (loading) loading.classList.add('hidden');
    } catch (error) {
      const loading = document.getElementById('upcoming-announcements-loading');
      if (loading) loading.classList.add('hidden');
      showMessage('Error loading upcoming announcements: ' + error.message, 'error');
    }
  }

  async function loadPendingLocationsOrgs() {
    try {
      const [locRes, orgRes] = await Promise.all([
        fetch('/api/admin/locations?all=true', { credentials: 'include' }),
        fetch('/api/admin/organizations?all=true', { credentials: 'include' }),
      ]);
      const locations = locRes.ok ? await locRes.json() : [];
      const organizations = orgRes.ok ? await orgRes.json() : [];
      const pendingLoc = locations.filter(l => l.status === 'pending').length;
      const pendingOrg = organizations.filter(o => o.status === 'pending').length;
      const block = document.getElementById('pending-locations-orgs');
      const locCountEl = document.getElementById('pending-locations-count');
      const orgCountEl = document.getElementById('pending-organizations-count');
      const locLink = document.getElementById('pending-locations-link');
      const orgLink = document.getElementById('pending-organizations-link');
      if (locCountEl) locCountEl.textContent = String(pendingLoc);
      if (orgCountEl) orgCountEl.textContent = String(pendingOrg);
      if (block) {
        if (pendingLoc > 0 || pendingOrg > 0) {
          block.classList.remove('hidden');
        } else {
          block.classList.add('hidden');
        }
      }
    } catch (e) {
      // Non-fatal: leave section hidden
    }
  }

  /**
   * Displays upcoming announcements in a table format (read-only with edit option)
   */
  function displayUpcomingAnnouncements(announcements) {
    const container = document.getElementById('upcoming-announcements-container');
    const loading = document.getElementById('upcoming-announcements-loading');
    if (loading) loading.classList.add('hidden');
    if (announcements.length === 0) {
      container.innerHTML = '<p style="text-align:center;color:#888;">No upcoming announcements.</p>';
      return;
    }
    const table =
      '<table class="data-table">' +
      '<thead>' +
      '<tr>' +
      '<th>Title</th>' +
      '<th>Message</th>' +
      '<th>Email</th>' +
      '<th>Show At</th>' +
      '<th>Expires At</th>' +
      '<th>Actions</th>' +
      '</tr>' +
      '</thead>' +
      '<tbody>' +
      announcements
        .map(function (a) {
          return (
            '<tr>' +
            '<td>' + (a.title || 'N/A') + '</td>' +
            '<td>' + (a.message || '').substring(0, 100) + (a.message && a.message.length > 100 ? '...' : '') + '</td>' +
            '<td>' + (a.email || 'N/A') + '</td>' +
            '<td>' + (a.show_at ? new Date(a.show_at).toLocaleString() : 'N/A') + '</td>' +
            '<td>' + (a.expires_at ? new Date(a.expires_at).toLocaleString() : 'N/A') + '</td>' +
            '<td style="text-align: center; white-space: nowrap;">' +
            '<button onclick="editExistingAnnouncement(\'' + a.id + '\')" class="icon-btn btn-edit" style="padding: 0.5rem; min-width: auto;" aria-label="Edit announcement">' +
            '<span class="material-symbols-outlined" style="font-size: 1.25rem;">edit</span>' +
            '<span class="tooltip">Edit</span>' +
            '</button>' +
            '</td>' +
            '</tr>'
          );
        })
        .join('') +
      '</tbody>' +
      '</table>';
    container.innerHTML = table;
  }

  /**
   * Displays events in a table format
   * @param {Array} events - Array of event objects to display
   * @param {string} containerId - ID of the container element
   * @param {string} loadingId - ID of the loading indicator
   * @param {boolean} isStaged - Whether these are staged events (for date column header)
   */
  function displayEvents(events, containerId = 'events-container', loadingId = 'loading', isStaged = true) {
      const container = document.getElementById(containerId);
    if (!container) {
      console.error('Container not found:', containerId);
      return;
    }
      const loading = document.getElementById(loadingId);
    if (loading) loading.classList.add('hidden');
      if (events.length === 0) {
        container.innerHTML = '<p style="text-align:center;color:#888;">No events to review.</p>';
        return;
      }
      const table =
      '<table class="data-table">' +
        '<thead>' +
        '<tr>' +
        '<th>Title</th>' +
        '<th>Date</th>' +
        '<th>Time</th>' +
        '<th>Location</th>' +
        '<th>Organization</th>' +
        '<th>Email</th>' +
        '<th>Comments</th>' +
        '<th>Description</th>' +
      '<th>Created</th>' +
        '<th>Actions</th>' +
        '</tr>' +
        '</thead>' +
        '<tbody>' +
        events
          .map(function (event) {
          // Use isStaged property if available, otherwise fall back to parameter
          const eventIsStaged = event.isStaged !== undefined ? event.isStaged : isStaged;
          
            const locationDisplay = event.location_added ? 
              `<span style="color: #f57c00; font-weight: 500;">NEW: ${event.location_added}</span>` : 
              (event.location?.name || 'N/A');
            const organizationDisplay = event.organization_added ? 
              `<span style="color: #f57c00; font-weight: 500;">NEW: ${event.organization_added}</span>` : 
              (event.organization?.name || 'N/A');
            
          const dateField = eventIsStaged ? 'submitted_at' : 'created_at';
          const editFunction = eventIsStaged ? 'editStagedEvent' : 'editExistingEvent';
          const approveFunction = eventIsStaged ? 'approveEvent' : 'approveExistingEvent';
          const rejectFunction = eventIsStaged ? 'rejectEvent' : 'rejectExistingEvent';
          // For non-staged events (including pending), use "Archive" instead of "Reject"
          const rejectLabel = eventIsStaged ? 'Reject' : 'Archive';
          const rejectAriaLabel = eventIsStaged ? 'Reject event' : 'Archive event';
            
            return (
              '<tr>' +
              '<td>' + (event.title || 'N/A') + '</td>' +
              '<td>' + (event.start_date || 'N/A') + '</td>' +
              '<td>' + (event.start_time || 'N/A') + '</td>' +
              '<td>' + locationDisplay + '</td>' +
              '<td>' + organizationDisplay + '</td>' +
              '<td>' + (event.email || 'N/A') + '</td>' +
              '<td>' + (event.comments || '').substring(0, 50) + (event.comments && event.comments.length > 50 ? '...' : '') + '</td>' +
              '<td>' + (event.description || '').substring(0, 100) + (event.description && event.description.length > 100 ? '...' : '') + '</td>' +
              '<td>' + (event[dateField] ? new Date(event[dateField]).toLocaleDateString() : 'N/A') + '</td>' +
            '<td style="text-align: center; white-space: nowrap;">' +
            '<button onclick="' + editFunction + '(\'' + event.id + '\')" class="icon-btn btn-edit" style="padding: 0.5rem; min-width: auto; margin-right: 0.25rem;" aria-label="Edit event">' +
            '<span class="material-symbols-outlined" style="font-size: 1.25rem;">edit</span>' +
            '<span class="tooltip">Edit</span>' +
            '</button>' +
            '<button onclick="duplicateEvent(\'' + event.id + '\')" class="icon-btn" style="padding: 0.5rem; min-width: auto; margin-right: 0.25rem; background-color: #e0e7ff; color: #4f46e5;" aria-label="Duplicate event">' +
            '<span class="material-symbols-outlined" style="font-size: 1.25rem;">content_copy</span>' +
            '<span class="tooltip">Duplicate</span>' +
            '</button>' +
            '<button onclick="createSeriesFromEvent(\'' + event.id + '\')" class="icon-btn" style="padding: 0.5rem; min-width: auto; margin-right: 0.25rem; background-color: #dbeafe; color: #1e40af;" aria-label="Create series">' +
            '<span class="material-symbols-outlined" style="font-size: 1.25rem;">repeat</span>' +
            '<span class="tooltip">Create Series</span>' +
            '</button>' +
            '<button onclick="' + approveFunction + '(\'' + event.id + '\')" class="icon-btn btn-approve" style="padding: 0.5rem; min-width: auto; margin-right: 0.25rem;" aria-label="Approve event">' +
            '<span class="material-symbols-outlined" style="font-size: 1.25rem;">check</span>' +
            '<span class="tooltip">Approve</span>' +
            '</button>' +
            '<button onclick="' + rejectFunction + '(\'' + event.id + '\')" class="icon-btn btn-reject" style="padding: 0.5rem; min-width: auto;" aria-label="' + rejectAriaLabel + '">' +
            '<span class="material-symbols-outlined" style="font-size: 1.25rem;">archive</span>' +
            '<span class="tooltip">' + rejectLabel + '</span>' +
            '</button>' +
            '</td>' +
            '</tr>'
          );
        })
        .join('') +
      '</tbody>' +
      '</table>';
    container.innerHTML = table;
  }

  function displayAnnouncements(announcements, containerId = 'announcements-container', loadingId = 'announcements-loading', isStaged = true) {
    const container = document.getElementById(containerId);
    const loading = document.getElementById(loadingId);
    if (loading) loading.classList.add('hidden');
    if (announcements.length === 0) {
      container.innerHTML = '<p style="text-align:center;color:#888;">No announcements to review.</p>';
      return;
    }
    const table =
      '<table class="data-table">' +
      '<thead>' +
      '<tr>' +
      '<th>Title</th>' +
      '<th>Message</th>' +
      '<th>Email</th>' +
      '<th>Comments</th>' +
      '<th>Show At</th>' +
      '<th>Expires At</th>' +
      '<th>Created</th>' +
      '<th>Actions</th>' +
      '</tr>' +
      '</thead>' +
      '<tbody>' +
      announcements
        .map(function (a) {
          // Use isStaged property if available, otherwise fall back to checking if it's a staged announcement
          const announcementIsStaged = a.isStaged !== undefined ? a.isStaged : isStaged;
          const dateField = 'created_at';
          const editFunction = announcementIsStaged ? 'editStagedAnnouncement' : 'editExistingAnnouncement';
          const approveFunction = announcementIsStaged ? 'approveAnnouncement' : 'approveExistingAnnouncement';
          const rejectFunction = announcementIsStaged ? 'rejectAnnouncement' : 'rejectExistingAnnouncement';
          // For non-staged announcements (including pending), use "Archive" instead of "Reject"
          const rejectLabel = announcementIsStaged ? 'Reject' : 'Archive';
          const rejectAriaLabel = announcementIsStaged ? 'Reject announcement' : 'Archive announcement';
          
          return (
            '<tr>' +
            '<td>' + (a.title || 'N/A') + '</td>' +
            '<td>' + (a.message || '').substring(0, 100) + (a.message && a.message.length > 100 ? '...' : '') + '</td>' +
            '<td>' + (a.email || 'N/A') + '</td>' +
            '<td>' + (a.comments || '').substring(0, 50) + (a.comments && a.comments.length > 50 ? '...' : '') + '</td>' +
            '<td>' + (a.show_at ? new Date(a.show_at).toLocaleString() : 'N/A') + '</td>' +
            '<td>' + (a.expires_at ? new Date(a.expires_at).toLocaleString() : 'N/A') + '</td>' +
            '<td>' + (a[dateField] ? new Date(a[dateField]).toLocaleDateString() : 'N/A') + '</td>' +
            '<td style="text-align: center; white-space: nowrap;">' +
            '<button onclick="' + editFunction + '(\'' + a.id + '\')" class="icon-btn btn-edit" style="padding: 0.5rem; min-width: auto; margin-right: 0.25rem;" aria-label="Edit announcement">' +
            '<span class="material-symbols-outlined" style="font-size: 1.25rem;">edit</span>' +
            '<span class="tooltip">Edit</span>' +
            '</button>' +
            '<button onclick="' + approveFunction + '(\'' + a.id + '\')" class="icon-btn btn-approve" style="padding: 0.5rem; min-width: auto; margin-right: 0.25rem;" aria-label="Approve announcement">' +
            '<span class="material-symbols-outlined" style="font-size: 1.25rem;">check</span>' +
            '<span class="tooltip">Approve</span>' +
            '</button>' +
            '<button onclick="' + rejectFunction + '(\'' + a.id + '\')" class="icon-btn btn-reject" style="padding: 0.5rem; min-width: auto;" aria-label="' + rejectAriaLabel + '">' +
            '<span class="material-symbols-outlined" style="font-size: 1.25rem;">archive</span>' +
            '<span class="tooltip">' + rejectLabel + '</span>' +
            '</button>' +
            '</td>' +
            '</tr>'
          );
        })
        .join('') +
      '</tbody>' +
      '</table>';
    container.innerHTML = table;
  }

  document.addEventListener('DOMContentLoaded', async () => {
    try {
      // Load reference data first
      await loadReferenceData();

      // When a location is created from the Add Location modal, add to list and select it in event form
      window.addEventListener('admin:location-created', (e) => {
        const location = e.detail?.location;
        if (!location?.id) return;
        allLocations = allLocations.some(l => l.id === location.id) ? allLocations : [...allLocations, { id: location.id, name: location.name || '', address: location.address || '' }];
        const locIdEl = document.getElementById('editEventLocationId');
        const locSearchEl = document.getElementById('editEventLocationSearch');
        if (locIdEl) locIdEl.value = location.id;
        if (locSearchEl) locSearchEl.value = location.name || '';
      });
      window.addEventListener('admin:organization-created', (e) => {
        const organization = e.detail?.organization;
        if (!organization?.id) return;
        allOrganizations = allOrganizations.some(o => o.id === organization.id) ? allOrganizations : [...allOrganizations, { id: organization.id, name: organization.name || '' }];
        const orgIdEl = document.getElementById('editEventOrganizationId');
        const orgSearchEl = document.getElementById('editEventOrganizationSearch');
        if (orgIdEl) orgIdEl.value = organization.id;
        if (orgSearchEl) orgSearchEl.value = organization.name || '';
      });

      const cancelledCheckbox = document.getElementById('editEventCancelled');
      if (cancelledCheckbox) {
        cancelledCheckbox.addEventListener('change', syncEventStatusControls);
        syncEventStatusControls();
      }
      
      // Wait a bit for Astro components to fully render
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // Setup autocomplete with retry mechanism
      setupLocationAutocomplete();
      setupOrganizationAutocomplete();
      setupParentEventAutocomplete();
      setupAnnouncementOrganizationAutocomplete();
      
      await Promise.all([
        loadEventsToApprove(),
        loadIncompleteEvents(),
        loadAnnouncementsToApprove(),
        loadUpcomingAnnouncements(),
        loadPendingLocationsOrgs()
      ]);

      // Check if we should open edit modal for a specific event (from URL query param)
      const urlParams = new URLSearchParams(window.location.search);
      const editEventId = urlParams.get('editEvent');
      const duplicateEventId = urlParams.get('duplicateEvent');

      if (editEventId) {
        window.location.href = `/admin/events/${editEventId}`;
        return;
      }
      
      if (duplicateEventId) {
        // Handle duplicate event from URL parameter
        setTimeout(async () => {
          if (typeof duplicateEvent === 'function') {
            await duplicateEvent(duplicateEventId);
            window.history.replaceState({}, '', window.location.pathname);
          }
        }, 500);
      }
      
      if (editEventId) {
        // Wait for functions to be defined and data to be loaded
        const tryOpenEditModal = async () => {
          try {
            // Verify functions are available
            if (typeof editExistingEvent !== 'function' || typeof editStagedEvent !== 'function') {
              return false;
            }
            
            // Try to fetch the event directly first (works for all statuses including approved)
            try {
              const directResponse = await fetch(`/api/admin/events/${editEventId}`, { credentials: 'include' });
              if (directResponse.ok) {
                const directData = await directResponse.json();
                if (directData.event) {
                  await editExistingEvent(editEventId);
                  window.history.replaceState({}, '', window.location.pathname);
                  return true;
                }
              }
            } catch (err) {
              console.error('Error fetching event:', err);
            }
            
            // Fallback: Try to find the event in existing events first, then staged events
            const existingResponse = await fetch('/api/admin/events', { credentials: 'include' });
            const existingData = await existingResponse.json();
            const existingEvent = existingData.events && existingData.events.find(function(e) { return e.id === editEventId; });
            
            if (existingEvent) {
              await editExistingEvent(editEventId);
              window.history.replaceState({}, '', window.location.pathname);
              return true;
            }
            
            // Try staged events
            const stagedResponse = await fetch('/api/admin/events-staged', { credentials: 'include' });
            const stagedData = await stagedResponse.json();
            const stagedEvent = stagedData.events && stagedData.events.find(function(e) { return e.id === editEventId; });
            
            if (stagedEvent) {
              await editStagedEvent(editEventId);
              window.history.replaceState({}, '', window.location.pathname);
              return true;
            }
            
            showMessage('Event not found.', 'error');
            return false;
          } catch (err) {
            console.error('Error opening edit modal:', err);
            showMessage('Error opening edit modal: ' + err.message, 'error');
            return false;
          }
        };
        
        // Try immediately, then retry if needed
        setTimeout(async () => {
          if (!(await tryOpenEditModal())) {
            // Retry after a bit more time
            setTimeout(async () => {
              await tryOpenEditModal();
            }, 500);
          }
        }, 500);
      }
    } catch (err) {
      showMessage('Error loading admin dashboard: ' + err.message, 'error');
      // Hide all loading indicators
      ['loading', 'incomplete-loading', 'announcements-loading'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.classList.add('hidden');
      });
    }

    async function loadIncompleteEvents() {
      try {
        const loading = document.getElementById('incomplete-loading');
        const response = await fetch('/api/admin/events/incomplete', {
          credentials: 'include',
        });
        if (!response.ok) {
          if (response.status === 401) {
            if (typeof window.openLoginModal === 'function') {
              window.openLoginModal();
            } else {
              const currentUrl = encodeURIComponent(window.location.pathname + window.location.search);
              window.location.href = `/login?redirect=${currentUrl}`;
            }
            return;
          }
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        displayIncompleteEvents(data.events || []);
        if (loading) loading.classList.add('hidden');
      } catch (error) {
        const loading = document.getElementById('incomplete-loading');
        if (loading) loading.classList.add('hidden');
        const container = document.getElementById('incomplete-events-container');
        if (container) {
          container.innerHTML = '<p style="text-align:center;color:#888;">Error loading incomplete events: ' + error.message + '</p>';
        }
      }
    }

    function displayIncompleteEvents(events) {
      const container = document.getElementById('incomplete-events-container');
      if (!container) return;
      
      if (events.length === 0) {
        container.innerHTML = '<p style="text-align:center;color:#888;padding:2rem;">All approved events have locations and primary tags. Great job! </p>';
        return;
      }
      
      const table =
        '<table class="data-table">' +
        '<thead>' +
        '<tr>' +
        '<th>Title</th>' +
        '<th>Start Date</th>' +
        '<th>Location</th>' +
        '<th>Primary Tag</th>' +
        '<th style="text-align: center; width: 60px;"></th>' +
        '</tr>' +
        '</thead>' +
        '<tbody>' +
        events
          .map(function (event) {
            const missingLocation = !event.location_id;
            const missingPrimaryTag = !event.primary_tag_id;
            
            const locationDisplay = missingLocation 
              ? '<span class="material-symbols-outlined" style="color: #f59e0b; font-size: 1.25rem; vertical-align: middle;" title="Missing location">warning</span>' 
              : (event.location?.name || 'N/A');
            
            const primaryTagDisplay = missingPrimaryTag 
              ? '<span class="material-symbols-outlined" style="color: #f59e0b; font-size: 1.25rem; vertical-align: middle;" title="Missing primary tag">warning</span>' 
              : (event.primary_tag?.name || 'N/A');
            
            return (
              '<tr>' +
              '<td><strong>' + (event.title || 'N/A') + '</strong></td>' +
              '<td>' + (event.start_date ? new Date(event.start_date).toLocaleDateString() : 'N/A') + '</td>' +
              '<td>' + locationDisplay + '</td>' +
              '<td>' + primaryTagDisplay + '</td>' +
              '<td style="text-align: center; white-space: nowrap;">' +
              '<button onclick="editExistingEvent(\'' + event.id + '\')" class="icon-btn btn-edit" style="padding: 0.5rem; min-width: auto; margin-right: 0.25rem;" aria-label="Edit event">' +
              '<span class="material-symbols-outlined" style="font-size: 1.25rem;">edit</span>' +
              '<span class="tooltip">Edit</span>' +
              '</button>' +
              '<button onclick="duplicateEvent(\'' + event.id + '\')" class="icon-btn" style="padding: 0.5rem; min-width: auto; margin-right: 0.25rem; background-color: #e0e7ff; color: #4f46e5;" aria-label="Duplicate event">' +
              '<span class="material-symbols-outlined" style="font-size: 1.25rem;">content_copy</span>' +
              '<span class="tooltip">Duplicate</span>' +
              '</button>' +
              '<button onclick="createSeriesFromEvent(\'' + event.id + '\')" class="icon-btn" style="padding: 0.5rem; min-width: auto; background-color: #dbeafe; color: #1e40af;" aria-label="Create series">' +
              '<span class="material-symbols-outlined" style="font-size: 1.25rem;">repeat</span>' +
              '<span class="tooltip">Create Series</span>' +
              '</button>' +
              '</td>' +
              '</tr>'
            );
          })
          .join('') +
        '</tbody>' +
        '</table>';
      container.innerHTML = table;
    }

  /**
   * Approves a staged event, moving it to the events table
   * @param {string} eventId - The ID of the staged event to approve
   */
  async function approveEvent(eventId) {
    try {
      // First check if event has primary_tag
        const response = await fetch('/api/admin/events-staged', { credentials: 'include' });
        const data = await response.json();
        const event = data.events.find(e => e.id === eventId);
        
        if (!event) {
          showMessage('Event not found', 'error');
          return;
        }
        
        if (!event.primary_tag_id) {
          showMessage('Event must have a primary tag selected before approval. Please edit the event first.', 'error');
          return;
        }
        
        const approveResponse = await fetch('/api/admin/events-staged/approve', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          credentials: 'include', // Include cookies for session
          body: JSON.stringify({ eventId }),
        });
        if (!approveResponse.ok) {
          if (approveResponse.status === 401) {
            const currentUrl = encodeURIComponent(window.location.pathname + window.location.search);
            window.location.href = `/login?redirect=${currentUrl}`;
            return;
          }
          const errorData = await approveResponse.json();
          throw new Error(errorData.error || `HTTP error! status: ${approveResponse.status}`);
        }
        await approveResponse.json();
        showMessage('Event approved successfully!', 'success');
        loadEventsToApprove();
      } catch (error) {
        showMessage('Error approving event: ' + error.message, 'error');
      }
    }

  /**
   * Rejects a staged event
   * @param {string} eventId - The ID of the staged event to reject
   */
  async function rejectEvent(eventId) {
    const reason = prompt('Reason for rejection (optional):');
    try {
        const response = await fetch('/api/admin/events-staged/reject', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          credentials: 'include', // Include cookies for session
          body: JSON.stringify({ eventId, reason }),
        });
        if (!response.ok) {
          if (response.status === 401) {
            const currentUrl = encodeURIComponent(window.location.pathname + window.location.search);
            window.location.href = `/login?redirect=${currentUrl}`;
            return;
          }
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        await response.json();
        showMessage('Event rejected successfully!', 'success');
        loadEventsToApprove();
      } catch (error) {
        showMessage('Error rejecting event: ' + error.message, 'error');
      }
    }

  /**
   * Displays announcements in a table format
   * @param {Array} announcements - Array of announcement objects to display
   * @param {string} containerId - ID of the container element
   * @param {string} loadingId - ID of the loading indicator
   * @param {boolean} isStaged - Whether these are staged announcements (for date column header)
   */
  function displayAnnouncements(announcements, containerId = 'announcements-container', loadingId = 'announcements-loading', isStaged = true) {
      const container = document.getElementById(containerId);
      const loading = document.getElementById(loadingId);
      if (loading) loading.classList.add('hidden');
      if (announcements.length === 0) {
        container.innerHTML = '<p style="text-align:center;color:#888;">No announcements to review.</p>';
        return;
      }
      const table =
        '<table class="data-table">' +
        '<thead>' +
        '<tr>' +
        '<th>Title</th>' +
        '<th>Message</th>' +
        '<th>Email</th>' +
        '<th>Comments</th>' +
        '<th>Show At</th>' +
        '<th>Expires At</th>' +
        '<th>Created</th>' +
        '<th>Actions</th>' +
        '</tr>' +
        '</thead>' +
        '<tbody>' +
        announcements
          .map(function (a) {
            // Use isStaged property if available, otherwise fall back to checking if it's a staged announcement
            const announcementIsStaged = a.isStaged !== undefined ? a.isStaged : isStaged;
            const dateField = 'created_at';
            const editFunction = announcementIsStaged ? 'editStagedAnnouncement' : 'editExistingAnnouncement';
            const approveFunction = announcementIsStaged ? 'approveAnnouncement' : 'approveExistingAnnouncement';
            const rejectFunction = announcementIsStaged ? 'rejectAnnouncement' : 'rejectExistingAnnouncement';
            
            return (
              '<tr>' +
              '<td>' + (a.title || 'N/A') + '</td>' +
              '<td>' + (a.message || '').substring(0, 100) + (a.message && a.message.length > 100 ? '...' : '') + '</td>' +
              '<td>' + (a.email || 'N/A') + '</td>' +
              '<td>' + (a.comments || '').substring(0, 50) + (a.comments && a.comments.length > 50 ? '...' : '') + '</td>' +
              '<td>' + (a.show_at ? new Date(a.show_at).toLocaleString() : 'N/A') + '</td>' +
              '<td>' + (a.expires_at ? new Date(a.expires_at).toLocaleString() : 'N/A') + '</td>' +
              '<td>' + (a[dateField] ? new Date(a[dateField]).toLocaleDateString() : 'N/A') + '</td>' +
              '<td style="text-align: center; white-space: nowrap;">' +
              '<button onclick="' + editFunction + '(\'' + a.id + '\')" class="icon-btn btn-edit" style="padding: 0.5rem; min-width: auto; margin-right: 0.25rem;" aria-label="Edit announcement">' +
              '<span class="material-symbols-outlined" style="font-size: 1.25rem;">edit</span>' +
              '<span class="tooltip">Edit</span>' +
              '</button>' +
              '<button onclick="' + approveFunction + '(\'' + a.id + '\')" class="icon-btn btn-approve" style="padding: 0.5rem; min-width: auto; margin-right: 0.25rem;" aria-label="Approve announcement">' +
              '<span class="material-symbols-outlined" style="font-size: 1.25rem;">check</span>' +
              '<span class="tooltip">Approve</span>' +
              '</button>' +
              '<button onclick="' + rejectFunction + '(\'' + a.id + '\')" class="icon-btn btn-reject" style="padding: 0.5rem; min-width: auto;" aria-label="Reject announcement">' +
              '<span class="material-symbols-outlined" style="font-size: 1.25rem;">close</span>' +
              '<span class="tooltip">Reject</span>' +
              '</button>' +
              '</td>' +
              '</tr>'
            );
          })
          .join('') +
        '</tbody>' +
        '</table>';
      container.innerHTML = table;
    }

  /**
   * Approves a staged announcement, moving it to the announcements table
   * @param {string} announcementId - The ID of the staged announcement to approve
   */
  async function approveAnnouncement(announcementId) {
      try {
        const response = await fetch('/api/admin/announcements-staged/approve', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          credentials: 'include', // Include cookies for session
          body: JSON.stringify({ announcementId }),
        });
        if (!response.ok) {
          if (response.status === 401) {
            const currentUrl = encodeURIComponent(window.location.pathname + window.location.search);
            window.location.href = `/login?redirect=${currentUrl}`;
            return;
          }
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        await response.json();
        showMessage('Announcement approved successfully!', 'success');
        loadAnnouncementsToApprove();
      } catch (error) {
        showMessage('Error approving announcement: ' + error.message, 'error');
      }
    }
    
  /**
   * Rejects a staged announcement
   * @param {string} announcementId - The ID of the staged announcement to reject
   */
  async function rejectAnnouncement(announcementId) {
      const reason = prompt('Reason for rejection (optional):');
      try {
        const response = await fetch('/api/admin/announcements-staged/reject', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          credentials: 'include', // Include cookies for session
          body: JSON.stringify({ announcementId, reason }),
        });
        if (!response.ok) {
          if (response.status === 401) {
            const currentUrl = encodeURIComponent(window.location.pathname + window.location.search);
            window.location.href = `/login?redirect=${currentUrl}`;
            return;
          }
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        await response.json();
        showMessage('Announcement rejected successfully!', 'success');
        loadAnnouncementsToApprove();
      } catch (error) {
        showMessage('Error rejecting announcement: ' + error.message, 'error');
      }
    }

  // ============================================================================
  // EDIT MODAL STATE MANAGEMENT
  // ============================================================================
  
  // Track which item is currently being edited
  let currentEditId = null;
  let currentEditType = null; // 'staged-event', 'existing-event', 'staged-announcement', 'existing-announcement', 'new-event'

  // ============================================================================
  // EDIT FUNCTIONS
  // ============================================================================
  
  /**
   * Opens the edit modal for a staged event
   * @param {string} eventId - The ID of the event to edit
   */

    async function editStagedEvent(eventId) {
      currentEditId = eventId;
      currentEditType = 'staged-event';
      
      // Find the event data from the already loaded events
      const response = await fetch('/api/admin/events-staged', { credentials: 'include' });
      const data = await response.json();
      const event = data.events.find(e => e.id === eventId);
      
      if (event) {
        document.getElementById('editEventModalTitle').textContent = 'Edit Staged Event';
        document.getElementById('editEventTitle').value = event.title || '';
        document.getElementById('editEventDescription').value = event.description || '';
        document.getElementById('editEventStartDate').value = event.start_date || '';
        document.getElementById('editEventEndDate').value = event.end_date || '';
        document.getElementById('editEventStartTime').value = event.start_time || '';
        document.getElementById('editEventEndTime').value = event.end_time || '';
        document.getElementById('editEventEmail').value = event.email || '';
        document.getElementById('editEventWebsite').value = event.website || '';
        document.getElementById('editEventRegistrationLink').value = event.registration_link || '';
        document.getElementById('editEventExternalImageUrl').value = event.external_image_url || '';
        document.getElementById('editEventCost').value = event.cost || '';
        document.getElementById('editEventPrimaryTag').value = event.primary_tag_id || '';
        document.getElementById('editEventSecondaryTag').value = event.secondary_tag_id || '';
        
        // Set checkbox fields
        document.getElementById('editEventRegistration').checked = event.registration || false;
        document.getElementById('editEventExcludeFromCalendar').checked = event.exclude_from_calendar || false;
        document.getElementById('editEventFeatured').checked = event.featured || false;
        const isCancelled = event.status === 'cancelled';
        document.getElementById('editEventCancelled').checked = isCancelled;
        document.getElementById('editEventDraft').checked = !isCancelled && (event.status === 'pending' || event.status === null);
        syncEventStatusControls();
        
        // Set location
        if (event.location_id && event.location) {
          document.getElementById('editEventLocationSearch').value = event.location.name || '';
          document.getElementById('editEventLocationId').value = event.location_id;
        } else {
          document.getElementById('editEventLocationSearch').value = '';
          document.getElementById('editEventLocationId').value = '';
        }
        
        // Set organization
        if (event.organization_id && event.organization) {
          document.getElementById('editEventOrganizationSearch').value = event.organization.name || '';
          document.getElementById('editEventOrganizationId').value = event.organization_id;
        } else {
          document.getElementById('editEventOrganizationSearch').value = '';
          document.getElementById('editEventOrganizationId').value = '';
        }
        
        // Set parent event
        if (event.parent_event_id) {
          // Find the parent event in our loaded list
          const parentEvent = allParentEvents.find(e => e.id === event.parent_event_id);
          if (parentEvent) {
            document.getElementById('editEventParentEventSearch').value = parentEvent.title || '';
            document.getElementById('editEventParentEventId').value = event.parent_event_id;
          } else {
            // If not found, we'll need to fetch it or just show the ID
            document.getElementById('editEventParentEventSearch').value = '';
            document.getElementById('editEventParentEventId').value = event.parent_event_id;
          }
        } else {
          document.getElementById('editEventParentEventSearch').value = '';
          document.getElementById('editEventParentEventId').value = '';
        }
        
        document.getElementById('editEventComments').value = event.comments || '';
        const modal = document.getElementById('editEventModal');
        if (modal) {
          modal.classList.remove('hidden');
          modal.classList.add('flex');
          // Scroll to top of page to ensure modal is visible
          window.scrollTo({ top: 0, behavior: 'smooth' });
          // Ensure autocomplete is set up when modal opens
          setTimeout(ensureEventAutocompleteSetup, 50);
        }
      } else {
        showMessage('Event not found', 'error');
      }
    }

  /**
   * Opens the edit modal for an existing (approved) event
   * @param {string} eventId - The ID of the event to edit
   */
  async function editExistingEvent(eventId) {
      currentEditId = eventId;
      currentEditType = 'existing-event';
      
      // Try to find the event data from the already loaded events first
      let response = await fetch('/api/admin/events', { credentials: 'include' });
      let data = await response.json();
      let event = data.events && data.events.find(function(e) { return e.id === eventId; });
      
      // If not found, try fetching directly (might be an approved event)
      if (!event) {
        response = await fetch(`/api/admin/events/${eventId}`, { credentials: 'include' });
        if (response.ok) {
          data = await response.json();
          event = data.event;
        }
      }
      
      if (event) {
        document.getElementById('editEventModalTitle').textContent = 'Edit Existing Event';
        document.getElementById('editEventTitle').value = event.title || '';
        document.getElementById('editEventDescription').value = event.description || '';
        document.getElementById('editEventStartDate').value = event.start_date || '';
        document.getElementById('editEventEndDate').value = event.end_date || '';
        document.getElementById('editEventStartTime').value = event.start_time || '';
        document.getElementById('editEventEndTime').value = event.end_time || '';
        document.getElementById('editEventEmail').value = event.email || '';
        document.getElementById('editEventWebsite').value = event.website || '';
        document.getElementById('editEventRegistrationLink').value = event.registration_link || '';
        document.getElementById('editEventExternalImageUrl').value = event.external_image_url || '';
        document.getElementById('editEventCost').value = event.cost || '';
        document.getElementById('editEventPrimaryTag').value = event.primary_tag_id || '';
        document.getElementById('editEventSecondaryTag').value = event.secondary_tag_id || '';
        
        // Set checkbox fields
        document.getElementById('editEventRegistration').checked = event.registration || false;
        document.getElementById('editEventExcludeFromCalendar').checked = event.exclude_from_calendar || false;
        document.getElementById('editEventFeatured').checked = event.featured || false;
        const isCancelled = event.status === 'cancelled';
        document.getElementById('editEventCancelled').checked = isCancelled;
        document.getElementById('editEventDraft').checked = !isCancelled && (event.status === 'pending' || event.status === null);
        syncEventStatusControls();
        
        // Set location
        if (event.location_id && event.location) {
          document.getElementById('editEventLocationSearch').value = event.location.name || '';
          document.getElementById('editEventLocationId').value = event.location_id;
        } else {
          document.getElementById('editEventLocationSearch').value = '';
          document.getElementById('editEventLocationId').value = '';
        }
        
        // Set organization
        if (event.organization_id && event.organization) {
          document.getElementById('editEventOrganizationSearch').value = event.organization.name || '';
          document.getElementById('editEventOrganizationId').value = event.organization_id;
        } else {
          document.getElementById('editEventOrganizationSearch').value = '';
          document.getElementById('editEventOrganizationId').value = '';
        }
        
        // Set parent event
        if (event.parent_event_id) {
          // Find the parent event in our loaded list
          const parentEvent = allParentEvents.find(e => e.id === event.parent_event_id);
          if (parentEvent) {
            const dateStr = parentEvent.start_date ? new Date(parentEvent.start_date).toLocaleDateString() : '';
            const timeStr = parentEvent.start_time ? parentEvent.start_time.substring(0, 5) : '';
            const displayStr = `${parentEvent.title}${dateStr ? ` - ${dateStr}` : ''}${timeStr ? ` ${timeStr}` : ''}`;
            document.getElementById('editEventParentEventSearch').value = displayStr;
            document.getElementById('editEventParentEventId').value = event.parent_event_id;
          } else {
            // If not found in parent events list, try to find it in the current events list
            const allEvents = data.events || [];
            const parentInList = allEvents.find(e => e.id === event.parent_event_id);
            if (parentInList) {
              document.getElementById('editEventParentEventSearch').value = parentInList.title || '';
              document.getElementById('editEventParentEventId').value = event.parent_event_id;
            } else {
              // If still not found, just set the ID (user can search for it)
              document.getElementById('editEventParentEventSearch').value = '';
              document.getElementById('editEventParentEventId').value = event.parent_event_id;
            }
          }
        } else {
          document.getElementById('editEventParentEventSearch').value = '';
          document.getElementById('editEventParentEventId').value = '';
        }
        
        document.getElementById('editEventComments').value = event.comments || '';
        const modal = document.getElementById('editEventModal');
        if (modal) {
          modal.classList.remove('hidden');
          modal.classList.add('flex');
          // Scroll to top of page to ensure modal is visible
          window.scrollTo({ top: 0, behavior: 'smooth' });
          // Ensure autocomplete is set up when modal opens
          setTimeout(ensureEventAutocompleteSetup, 50);
        }
      } else {
        showMessage('Event not found', 'error');
      }
    }

  /**
   * Duplicates an event by opening the edit modal with pre-filled data
   * Preserves parent event relationship if the original event has one
   * @param {string} eventId - The ID of the event to duplicate
   */
  window.duplicateEvent = async function(eventId) {
    try {
      // Fetch the event data
      let response = await fetch('/api/admin/events', { credentials: 'include' });
      let data = await response.json();
      let event = data.events && data.events.find(e => e.id === eventId);
      
      // If not found, try fetching directly
      if (!event) {
        response = await fetch(`/api/admin/events/${eventId}`, { credentials: 'include' });
        if (response.ok) {
          data = await response.json();
          event = data.event;
        }
      }
      
      if (!event) {
        showMessage('Event not found', 'error');
        return;
      }
      
      // Open modal in "new event" mode with pre-filled data
      currentEditId = null;
      currentEditType = 'new-event';
      
      const titleElement = document.getElementById('editEventModalTitle');
      titleElement.textContent = 'Duplicate Event';
      // Add a visual highlight to make it obvious
      titleElement.style.color = '#4f46e5'; // Indigo color to match duplicate button
      titleElement.style.fontWeight = '600';
      
      // Pre-fill all fields
      document.getElementById('editEventTitle').value = event.title || '';
      document.getElementById('editEventDescription').value = event.description || '';
      // Don't pre-fill dates - user should set new date
      document.getElementById('editEventStartDate').value = '';
      document.getElementById('editEventEndDate').value = '';
      document.getElementById('editEventStartTime').value = event.start_time || '';
      document.getElementById('editEventEndTime').value = event.end_time || '';
      document.getElementById('editEventEmail').value = event.email || '';
      document.getElementById('editEventWebsite').value = event.website || '';
      document.getElementById('editEventRegistrationLink').value = event.registration_link || '';
      document.getElementById('editEventExternalImageUrl').value = event.external_image_url || '';
      document.getElementById('editEventCost').value = event.cost || '';
      document.getElementById('editEventPrimaryTag').value = event.primary_tag_id || '';
      document.getElementById('editEventSecondaryTag').value = event.secondary_tag_id || '';
      
      // Set checkbox fields
      document.getElementById('editEventRegistration').checked = event.registration || false;
      document.getElementById('editEventExcludeFromCalendar').checked = event.exclude_from_calendar || false;
      document.getElementById('editEventFeatured').checked = event.featured || false;
      document.getElementById('editEventDraft').checked = false; // New duplicates default to approved
      document.getElementById('editEventCancelled').checked = false;
      syncEventStatusControls();
      
      // Set location
      if (event.location_id && event.location) {
        document.getElementById('editEventLocationSearch').value = event.location.name || '';
        document.getElementById('editEventLocationId').value = event.location_id;
      } else {
        document.getElementById('editEventLocationSearch').value = '';
        document.getElementById('editEventLocationId').value = '';
      }
      
      // Set organization
      if (event.organization_id && event.organization) {
        document.getElementById('editEventOrganizationSearch').value = event.organization.name || '';
        document.getElementById('editEventOrganizationId').value = event.organization_id;
      } else {
        document.getElementById('editEventOrganizationSearch').value = '';
        document.getElementById('editEventOrganizationId').value = '';
      }
      
      // Set parent event (optional - user might want to change this)
      if (event.parent_event_id) {
        const parentEvent = allParentEvents.find(e => e.id === event.parent_event_id);
        if (parentEvent) {
          const dateStr = parentEvent.start_date ? new Date(parentEvent.start_date).toLocaleDateString() : '';
          const timeStr = parentEvent.start_time ? parentEvent.start_time.substring(0, 5) : '';
          const displayStr = `${parentEvent.title}${dateStr ? ` - ${dateStr}` : ''}${timeStr ? ` ${timeStr}` : ''}`;
          document.getElementById('editEventParentEventSearch').value = displayStr;
          document.getElementById('editEventParentEventId').value = event.parent_event_id;
        } else {
          document.getElementById('editEventParentEventSearch').value = '';
          document.getElementById('editEventParentEventId').value = event.parent_event_id;
        }
      } else {
        document.getElementById('editEventParentEventSearch').value = '';
        document.getElementById('editEventParentEventId').value = '';
      }
      
      document.getElementById('editEventComments').value = '';
      
      const modal = document.getElementById('editEventModal');
      if (modal) {
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        // Scroll page to top first
        window.scrollTo({ top: 0, behavior: 'instant' });
        // Then scroll the modal container to top and ensure page stays at top
        setTimeout(() => {
          const modalContainer = modal.querySelector('.modal-container');
          if (modalContainer) {
            modalContainer.scrollTop = 0;
          }
          // Ensure page is at top
          window.scrollTo({ top: 0, behavior: 'instant' });
          // Scroll the modal header into view
          const modalHeader = modal.querySelector('.modal-header');
          if (modalHeader) {
            modalHeader.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 50);
        setTimeout(ensureEventAutocompleteSetup, 50);
      }
    } catch (error) {
      showMessage('Error duplicating event: ' + error.message, 'error');
    }
  };

  /**
   * Duplicates the event currently in the edit modal
   */
  window.duplicateCurrentEvent = async function() {
    // If we have an existing event ID, use it
    if (currentEditId) {
      duplicateEvent(currentEditId);
      return;
    }
    
    // Otherwise, get current form data and create a duplicate from it
    // This handles the case where user is creating a new event and wants to duplicate it
    const eventData = {
      title: document.getElementById('editEventTitle').value,
      description: document.getElementById('editEventDescription').value,
      start_date: document.getElementById('editEventStartDate').value,
      end_date: document.getElementById('editEventEndDate').value,
      start_time: document.getElementById('editEventStartTime').value,
      end_time: document.getElementById('editEventEndTime').value,
      email: document.getElementById('editEventEmail').value,
      website: document.getElementById('editEventWebsite').value,
      registration_link: document.getElementById('editEventRegistrationLink').value,
      external_image_url: document.getElementById('editEventExternalImageUrl').value,
      cost: document.getElementById('editEventCost').value,
      primary_tag_id: document.getElementById('editEventPrimaryTag').value,
      secondary_tag_id: document.getElementById('editEventSecondaryTag').value,
      location_id: document.getElementById('editEventLocationId').value,
      organization_id: document.getElementById('editEventOrganizationId').value,
      parent_event_id: document.getElementById('editEventParentEventId').value,
      registration: document.getElementById('editEventRegistration').checked,
      exclude_from_calendar: document.getElementById('editEventExcludeFromCalendar').checked,
      featured: document.getElementById('editEventFeatured').checked,
      status: getEventStatusFromForm(),
    };
    
    // Get location/organization display names for pre-filling duplicate form
    if (eventData.location_id) {
      const loc = allLocations.find(l => l.id === eventData.location_id);
      eventData.location_name = loc ? loc.name : document.getElementById('editEventLocationSearch').value || '';
    } else {
      eventData.location_name = '';
    }
    if (eventData.organization_id) {
      const org = allOrganizations.find(o => o.id === eventData.organization_id);
      eventData.organization_name = org ? org.name : document.getElementById('editEventOrganizationSearch').value || '';
    } else {
      eventData.organization_name = '';
    }
    
    // Open duplicate modal with form data (dates will be cleared)
    currentEditId = null;
    currentEditType = 'new-event';
    
    const titleElement = document.getElementById('editEventModalTitle');
    titleElement.textContent = 'Duplicate Event';
    // Add a visual highlight to make it obvious
    titleElement.style.color = '#4f46e5'; // Indigo color to match duplicate button
    titleElement.style.fontWeight = '600';
    
    // Pre-fill all fields except dates
    document.getElementById('editEventTitle').value = eventData.title || '';
    document.getElementById('editEventDescription').value = eventData.description || '';
    document.getElementById('editEventStartDate').value = '';
    document.getElementById('editEventEndDate').value = '';
    document.getElementById('editEventStartTime').value = eventData.start_time || '';
    document.getElementById('editEventEndTime').value = eventData.end_time || '';
    document.getElementById('editEventEmail').value = eventData.email || '';
    document.getElementById('editEventWebsite').value = eventData.website || '';
    document.getElementById('editEventRegistrationLink').value = eventData.registration_link || '';
    document.getElementById('editEventExternalImageUrl').value = eventData.external_image_url || '';
    document.getElementById('editEventCost').value = eventData.cost || '';
    document.getElementById('editEventPrimaryTag').value = eventData.primary_tag_id || '';
    document.getElementById('editEventSecondaryTag').value = eventData.secondary_tag_id || '';
    
    // Set checkbox fields
    document.getElementById('editEventRegistration').checked = eventData.registration || false;
    document.getElementById('editEventExcludeFromCalendar').checked = eventData.exclude_from_calendar || false;
    document.getElementById('editEventFeatured').checked = eventData.featured || false;
    document.getElementById('editEventDraft').checked = false;
    document.getElementById('editEventCancelled').checked = false;
    syncEventStatusControls();
    
    // Set location (from current form)
    document.getElementById('editEventLocationSearch').value = eventData.location_name || '';
    document.getElementById('editEventLocationId').value = eventData.location_id || '';
    
    // Set organization (from current form)
    document.getElementById('editEventOrganizationSearch').value = eventData.organization_name || '';
    document.getElementById('editEventOrganizationId').value = eventData.organization_id || '';
    
    // Set parent event
    if (eventData.parent_event_id) {
      const parentEvent = allParentEvents.find(e => e.id === eventData.parent_event_id);
      if (parentEvent) {
        const dateStr = parentEvent.start_date ? new Date(parentEvent.start_date).toLocaleDateString() : '';
        const timeStr = parentEvent.start_time ? parentEvent.start_time.substring(0, 5) : '';
        const displayStr = `${parentEvent.title}${dateStr ? ` - ${dateStr}` : ''}${timeStr ? ` ${timeStr}` : ''}`;
        document.getElementById('editEventParentEventSearch').value = displayStr;
        document.getElementById('editEventParentEventId').value = eventData.parent_event_id;
      } else {
        document.getElementById('editEventParentEventSearch').value = '';
        document.getElementById('editEventParentEventId').value = eventData.parent_event_id;
      }
    } else {
      document.getElementById('editEventParentEventSearch').value = '';
      document.getElementById('editEventParentEventId').value = '';
    }
    
    document.getElementById('editEventComments').value = '';
    
    const modal = document.getElementById('editEventModal');
    if (modal) {
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      // Scroll page to top first
      window.scrollTo({ top: 0, behavior: 'instant' });
      // Then scroll the modal container to top and ensure page stays at top
      setTimeout(() => {
        const modalContainer = modal.querySelector('.modal-container');
        if (modalContainer) {
          modalContainer.scrollTop = 0;
        }
        window.scrollTo({ top: 0, behavior: 'instant' });
        const modalHeader = modal.querySelector('.modal-header');
        if (modalHeader) {
          modalHeader.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }, 50);
      setTimeout(ensureEventAutocompleteSetup, 50);
    }
  };

  /**
   * Creates a series from an event
   * @param {string} eventId - The ID of the event to create a series from
   */
  window.createSeriesFromEvent = async function(eventId) {
    try {
      // Fetch the event data
      let response = await fetch('/api/admin/events', { credentials: 'include' });
      let data = await response.json();
      let event = data.events && data.events.find(e => e.id === eventId);
      
      // If not found, try fetching directly
      if (!event) {
        response = await fetch(`/api/admin/events/${eventId}`, { credentials: 'include' });
        if (response.ok) {
          data = await response.json();
          event = data.event;
        }
      }
      
      if (!event) {
        showMessage('Event not found', 'error');
        return;
      }
      
      // Track the original event ID
      seriesOriginalEventId = eventId;
      
      // Open series creation modal
      openSeriesModal(event);
    } catch (error) {
      showMessage('Error opening series creator: ' + error.message, 'error');
    }
  };

  /**
   * Creates a series from the event currently in the edit modal
   */
  window.createSeriesFromCurrentEvent = async function() {
    // If we have an existing event ID, fetch the full event data
    if (currentEditId) {
      seriesOriginalEventId = currentEditId; // Track the original event ID
      createSeriesFromEvent(currentEditId);
      return;
    }
    
    // Otherwise, get current form data (no original event ID)
    seriesOriginalEventId = null;
    const eventData = {
      title: document.getElementById('editEventTitle').value,
      description: document.getElementById('editEventDescription').value,
      start_date: document.getElementById('editEventStartDate').value,
      end_date: document.getElementById('editEventEndDate').value,
      start_time: document.getElementById('editEventStartTime').value,
      end_time: document.getElementById('editEventEndTime').value,
      email: document.getElementById('editEventEmail').value,
      website: document.getElementById('editEventWebsite').value,
      registration_link: document.getElementById('editEventRegistrationLink').value,
      external_image_url: document.getElementById('editEventExternalImageUrl').value,
      cost: document.getElementById('editEventCost').value,
      primary_tag_id: document.getElementById('editEventPrimaryTag').value,
      secondary_tag_id: document.getElementById('editEventSecondaryTag').value,
      location_id: document.getElementById('editEventLocationId').value,
      organization_id: document.getElementById('editEventOrganizationId').value,
      parent_event_id: document.getElementById('editEventParentEventId').value,
      registration: document.getElementById('editEventRegistration').checked,
      exclude_from_calendar: document.getElementById('editEventExcludeFromCalendar').checked,
      featured: document.getElementById('editEventFeatured').checked,
      status: getEventStatusFromForm(),
    };
    
    // Get location name if available
    if (eventData.location_id) {
      const loc = allLocations.find(l => l.id === eventData.location_id);
      if (loc) {
        eventData.location = { name: loc.name };
      }
    }
    
    // Get organization name if available
    if (eventData.organization_id) {
      const org = allOrganizations.find(o => o.id === eventData.organization_id);
      if (org) {
        eventData.organization = { name: org.name };
      }
    }
    
    openSeriesModal(eventData);
  };

  // ============================================================================
  // SERIES CREATION FUNCTIONS
  // ============================================================================

  let seriesTemplateEvent = null;
  let seriesOriginalEventId = null; // Track the original event ID if creating from existing event

  /**
   * Opens the series modal for creating a new series from scratch
   */
  window.openCreateSeriesModal = function() {
    seriesTemplateEvent = null; // No template event
    seriesOriginalEventId = null;
    
    // Clear all fields
    document.getElementById('seriesEventTitle').value = '';
    document.getElementById('seriesPattern').value = '';
    document.getElementById('seriesStartDate').value = '';
    document.getElementById('seriesOccurrences').value = '4';
    document.getElementById('seriesStartDateMonthly').value = '';
    document.getElementById('seriesOccurrencesMonthly').value = '3';
    document.getElementById('customDates').value = '';
    document.getElementById('seriesDescription').value = '';
    document.getElementById('seriesStartTime').value = '';
    document.getElementById('seriesEndTime').value = '';
    document.getElementById('seriesEmail').value = '';
    document.getElementById('seriesWebsite').value = '';
    document.getElementById('seriesRegistrationLink').value = '';
    document.getElementById('seriesExternalImageUrl').value = '';
    document.getElementById('seriesCost').value = '';
    document.getElementById('seriesPrimaryTag').value = '';
    document.getElementById('seriesSecondaryTag').value = '';
    document.getElementById('seriesLocationSearch').value = '';
    document.getElementById('seriesLocationId').value = '';
    document.getElementById('seriesLocationAdded').value = '';
    document.getElementById('seriesOrganizationSearch').value = '';
    document.getElementById('seriesOrganizationId').value = '';
    document.getElementById('seriesOrganizationAdded').value = '';
    document.getElementById('seriesRegistration').checked = false;
    document.getElementById('seriesExcludeFromCalendar').checked = false;
    document.getElementById('seriesFeatured').checked = false;
    document.getElementById('seriesCreateParent').checked = true; // Default to creating parent
    document.getElementById('seriesComments').value = '';
    document.getElementById('seriesSaveAsDraft').checked = false;
    
    // Reset calendar
    selectedDatesSet.clear();
    calendarCurrentMonth = new Date().getMonth();
    calendarCurrentYear = new Date().getFullYear();
    const manualInput = document.getElementById('customDatesManual');
    if (manualInput) manualInput.value = '';
    
    // Hide pattern options
    document.getElementById('weeklyOptions').classList.add('hidden');
    document.getElementById('monthlyOptions').classList.add('hidden');
    document.getElementById('customDatesOptions').classList.add('hidden');
    document.getElementById('seriesPreview').classList.add('hidden');
    
    // Show "add new" fields
    const locationContainer = document.getElementById('seriesLocationAddedContainer');
    const orgContainer = document.getElementById('seriesOrganizationAddedContainer');
    if (locationContainer) locationContainer.classList.remove('hidden');
    if (orgContainer) orgContainer.classList.remove('hidden');
    
    // Show parent option
    const createParentContainer = document.getElementById('seriesCreateParent')?.closest('.form-field');
    if (createParentContainer) createParentContainer.style.display = 'block';
    
    const modal = document.getElementById('seriesModal');
    if (modal) {
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      window.scrollTo({ top: 0, behavior: 'smooth' });
      // Setup autocomplete for series modal
      setTimeout(() => {
        setupSeriesLocationAutocomplete();
        setupSeriesOrganizationAutocomplete();
      }, 50);
    }
  };

  /**
   * Opens the series modal with event template data
   * @param {Object} event - Event data to use as template (optional)
   */
  window.openSeriesModal = function(event) {
    seriesTemplateEvent = event || null;
    
    // Pre-fill title if we have a template event
    if (event && event.title) {
      document.getElementById('seriesEventTitle').value = event.title;
    } else {
      document.getElementById('seriesEventTitle').value = '';
    }
    
    // Pre-fill common fields from template (if available)
    if (event) {
      document.getElementById('seriesDescription').value = event.description || '';
      document.getElementById('seriesStartTime').value = event.start_time || '';
      document.getElementById('seriesEndTime').value = event.end_time || '';
      document.getElementById('seriesEmail').value = event.email || '';
      document.getElementById('seriesWebsite').value = event.website || '';
      document.getElementById('seriesRegistrationLink').value = event.registration_link || '';
      document.getElementById('seriesExternalImageUrl').value = event.external_image_url || '';
      document.getElementById('seriesCost').value = event.cost || '';
      document.getElementById('seriesPrimaryTag').value = event.primary_tag_id || '';
      document.getElementById('seriesSecondaryTag').value = event.secondary_tag_id || '';
      document.getElementById('seriesRegistration').checked = event.registration || false;
      document.getElementById('seriesExcludeFromCalendar').checked = event.exclude_from_calendar || false;
      document.getElementById('seriesFeatured').checked = event.featured || false;
      
      // Pre-fill location if available
      if (event.location_id && event.location) {
        document.getElementById('seriesLocationSearch').value = event.location.name || '';
        document.getElementById('seriesLocationId').value = event.location_id;
      } else if (event.location) {
        document.getElementById('seriesLocationSearch').value = event.location.name || '';
        document.getElementById('seriesLocationId').value = event.location_id || '';
      }
      
      // Pre-fill organization if available
      if (event.organization_id && event.organization) {
        document.getElementById('seriesOrganizationSearch').value = event.organization.name || '';
        document.getElementById('seriesOrganizationId').value = event.organization_id;
      } else if (event.organization) {
        document.getElementById('seriesOrganizationSearch').value = event.organization.name || '';
        document.getElementById('seriesOrganizationId').value = event.organization_id || '';
      }
    } else {
      // Clear fields if no template
      document.getElementById('seriesDescription').value = '';
      document.getElementById('seriesStartTime').value = '';
      document.getElementById('seriesEndTime').value = '';
      document.getElementById('seriesEmail').value = '';
      document.getElementById('seriesWebsite').value = '';
      document.getElementById('seriesRegistrationLink').value = '';
      document.getElementById('seriesExternalImageUrl').value = '';
      document.getElementById('seriesCost').value = '';
      document.getElementById('seriesPrimaryTag').value = '';
      document.getElementById('seriesSecondaryTag').value = '';
      document.getElementById('seriesRegistration').checked = false;
      document.getElementById('seriesExcludeFromCalendar').checked = false;
      document.getElementById('seriesFeatured').checked = false;
      document.getElementById('seriesLocationSearch').value = '';
      document.getElementById('seriesLocationId').value = '';
      document.getElementById('seriesOrganizationSearch').value = '';
      document.getElementById('seriesOrganizationId').value = '';
    }
    
    // Set parent event checkbox - checked if template doesn't have a parent
    // Hide the checkbox container if template already has a parent (all series events will use existing parent)
    const createParentContainer = document.getElementById('seriesCreateParent')?.closest('.form-field');
    const createParentCheckbox = document.getElementById('seriesCreateParent');
    if (createParentCheckbox) {
      if (event && event.parent_event_id) {
        // Template has a parent - hide the option (all series events will use existing parent)
        if (createParentContainer) createParentContainer.style.display = 'none';
        createParentCheckbox.checked = false;
      } else {
        // Template doesn't have a parent - show option to create one
        if (createParentContainer) createParentContainer.style.display = 'block';
        createParentCheckbox.checked = true; // Default to creating a parent
      }
    }
    
    // Set draft checkbox - default to false (approved)
    const draftCheckbox = document.getElementById('seriesSaveAsDraft');
    if (draftCheckbox) {
      draftCheckbox.checked = false;
    }
    
    // Show "add new" fields
    const locationContainer = document.getElementById('seriesLocationAddedContainer');
    const orgContainer = document.getElementById('seriesOrganizationAddedContainer');
    if (locationContainer) locationContainer.classList.remove('hidden');
    if (orgContainer) orgContainer.classList.remove('hidden');
    
    const modal = document.getElementById('seriesModal');
    if (modal) {
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      window.scrollTo({ top: 0, behavior: 'smooth' });
      // Setup autocomplete for series modal
      setTimeout(() => {
        setupSeriesLocationAutocomplete();
        setupSeriesOrganizationAutocomplete();
      }, 50);
    }
  };

  /**
   * Closes the series creation modal
   */
  window.closeSeriesModal = function() {
    const modal = document.getElementById('seriesModal');
    if (modal) {
      modal.classList.add('hidden');
      modal.classList.remove('flex');
    }
    seriesTemplateEvent = null;
    // Reset form
    document.getElementById('seriesForm').reset();
    document.getElementById('seriesPreview').classList.add('hidden');
    document.getElementById('weeklyOptions').classList.add('hidden');
    document.getElementById('monthlyOptions').classList.add('hidden');
    document.getElementById('customDatesOptions').classList.add('hidden');
    // Reset checkboxes and show parent option again
    const createParentContainer = document.getElementById('seriesCreateParent')?.closest('.form-field');
    if (createParentContainer) createParentContainer.style.display = 'block';
    document.getElementById('seriesCreateParent').checked = false;
    document.getElementById('seriesSaveAsDraft').checked = false;
    // Reset calendar
    selectedDatesSet.clear();
    calendarCurrentMonth = new Date().getMonth();
    calendarCurrentYear = new Date().getFullYear();
    const manualInput = document.getElementById('customDatesManual');
    if (manualInput) manualInput.value = '';
    // Reset original event ID tracking
    seriesOriginalEventId = null;
    // Reset form fields
    document.getElementById('seriesEventTitle').value = '';
    document.getElementById('seriesPattern').value = '';
  };

  /**
   * Sets up location autocomplete for series modal
   */
  function setupSeriesLocationAutocomplete() {
    const searchInput = document.getElementById('seriesLocationSearch');
    const hiddenInput = document.getElementById('seriesLocationId');
    const dropdown = document.getElementById('seriesLocationDropdown');
    
    if (!searchInput || !hiddenInput || !dropdown) {
      setTimeout(setupSeriesLocationAutocomplete, 100);
      return;
    }
    
    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase().trim();
      if (query.length === 0) {
        dropdown.classList.add('hidden');
        hiddenInput.value = '';
        return;
      }
      
      if (!allLocations || !Array.isArray(allLocations)) return;
      
      const matches = allLocations.filter(loc => 
        loc && loc.name && loc.name.toLowerCase().includes(query)
      ).slice(0, 10);
      
      if (matches.length === 0) {
        dropdown.classList.add('hidden');
        return;
      }
      
      dropdown.innerHTML = matches.map(loc => `
        <div class="autocomplete-dropdown-item" onclick="selectSeriesLocation('${loc.id}', '${loc.name.replace(/'/g, "\\'")}')">
          ${loc.name}
        </div>
      `).join('');
      dropdown.classList.remove('hidden');
      dropdown.classList.add('block');
    });
  }

  /**
   * Sets up organization autocomplete for series modal
   */
  function setupSeriesOrganizationAutocomplete() {
    const searchInput = document.getElementById('seriesOrganizationSearch');
    const hiddenInput = document.getElementById('seriesOrganizationId');
    const dropdown = document.getElementById('seriesOrganizationDropdown');
    
    if (!searchInput || !hiddenInput || !dropdown) {
      setTimeout(setupSeriesOrganizationAutocomplete, 100);
      return;
    }
    
    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase().trim();
      if (query.length === 0) {
        dropdown.classList.add('hidden');
        hiddenInput.value = '';
        return;
      }
      
      if (!allOrganizations || !Array.isArray(allOrganizations)) return;
      
      const matches = allOrganizations.filter(org => 
        org && org.name && org.name.toLowerCase().includes(query)
      ).slice(0, 10);
      
      if (matches.length === 0) {
        dropdown.classList.add('hidden');
        return;
      }
      
      dropdown.innerHTML = matches.map(org => `
        <div class="autocomplete-dropdown-item" onclick="selectSeriesOrganization('${org.id}', '${org.name.replace(/'/g, "\\'")}')">
          ${org.name}
        </div>
      `).join('');
      dropdown.classList.remove('hidden');
      dropdown.classList.add('block');
    });
  }

  window.selectSeriesLocation = function(id, name) {
    document.getElementById('seriesLocationId').value = id;
    document.getElementById('seriesLocationSearch').value = name;
    const dropdown = document.getElementById('seriesLocationDropdown');
    dropdown.classList.add('hidden');
    dropdown.classList.remove('block');
    document.getElementById('seriesLocationAdded').value = '';
  };

  window.selectSeriesOrganization = function(id, name) {
    document.getElementById('seriesOrganizationId').value = id;
    document.getElementById('seriesOrganizationSearch').value = name;
    const dropdown = document.getElementById('seriesOrganizationDropdown');
    dropdown.classList.add('hidden');
    dropdown.classList.remove('block');
    document.getElementById('seriesOrganizationAdded').value = '';
  };

  // ============================================================================
  // CALENDAR MULTI-PICKER FUNCTIONS
  // ============================================================================

  let calendarCurrentMonth = new Date().getMonth();
  let calendarCurrentYear = new Date().getFullYear();
  let selectedDatesSet = new Set();

  /**
   * Initializes the calendar multi-picker
   */
  function initCalendarMultiPicker() {
    renderCalendar();
    updateSelectedDatesDisplay();
  }

  /**
   * Renders the calendar grid for the current month
   */
  function renderCalendar() {
    const grid = document.getElementById('calendarGrid');
    const monthYear = document.getElementById('calendarMonthYear');
    if (!grid || !monthYear) return;

    // Clear existing days (keep headers)
    const headers = grid.querySelectorAll('div:not(.text-center)');
    headers.forEach(h => {
      if (!h.classList.contains('text-sm') || !h.classList.contains('font-semibold')) {
        h.remove();
      }
    });

    // Update month/year display
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                       'July', 'August', 'September', 'October', 'November', 'December'];
    monthYear.textContent = `${monthNames[calendarCurrentMonth]} ${calendarCurrentYear}`;

    // Get first day of month and number of days
    const firstDay = new Date(calendarCurrentYear, calendarCurrentMonth, 1);
    const lastDay = new Date(calendarCurrentYear, calendarCurrentMonth + 1, 0);
    const daysInMonth = lastDay.getDate();
    const startingDayOfWeek = firstDay.getDay();

    // Add empty cells for days before month starts
    for (let i = 0; i < startingDayOfWeek; i++) {
      const emptyCell = document.createElement('div');
      emptyCell.className = 'h-10';
      grid.appendChild(emptyCell);
    }

    // Add cells for each day of the month
    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(calendarCurrentYear, calendarCurrentMonth, day);
      const dateStr = date.toISOString().split('T')[0];
      const isSelected = selectedDatesSet.has(dateStr);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const dateOnly = new Date(date);
      dateOnly.setHours(0, 0, 0, 0);
      const isToday = dateOnly.getTime() === today.getTime();

      const dayCell = document.createElement('div');
      dayCell.className = `h-10 flex items-center justify-center cursor-pointer rounded transition-colors ${
        isSelected 
          ? 'bg-indigo-500 text-white font-semibold' 
          : isToday
          ? 'bg-blue-100 text-blue-700 font-semibold'
          : 'hover:bg-gray-100 text-gray-700'
      }`;
      dayCell.textContent = day;
      dayCell.onclick = () => toggleDateSelection(dateStr);
      
      grid.appendChild(dayCell);
    }
  }

  /**
   * Toggles date selection
   */
  function toggleDateSelection(dateStr) {
    if (selectedDatesSet.has(dateStr)) {
      selectedDatesSet.delete(dateStr);
    } else {
      selectedDatesSet.add(dateStr);
    }
    renderCalendar();
    updateSelectedDatesDisplay();
    updateCustomDatesInput();
    updateSeriesPreview();
  }

  /**
   * Changes the calendar month
   */
  window.changeCalendarMonth = function(delta) {
    calendarCurrentMonth += delta;
    if (calendarCurrentMonth < 0) {
      calendarCurrentMonth = 11;
      calendarCurrentYear--;
    } else if (calendarCurrentMonth > 11) {
      calendarCurrentMonth = 0;
      calendarCurrentYear++;
    }
    renderCalendar();
  };

  /**
   * Updates the selected dates display
   */
  function updateSelectedDatesDisplay() {
    const list = document.getElementById('selectedDatesList');
    if (!list) return;

    const sortedDates = Array.from(selectedDatesSet).sort();
    
    if (sortedDates.length === 0) {
      list.innerHTML = '<p class="text-sm text-gray-500 m-0">No dates selected</p>';
      return;
    }

    list.innerHTML = sortedDates.map(dateStr => {
      const date = new Date(dateStr);
      const formatted = date.toLocaleDateString('en-US', { 
        weekday: 'short', 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric' 
      });
      return `<span class="inline-flex items-center gap-1 px-2 py-1 bg-indigo-100 text-indigo-700 rounded text-sm">
        ${formatted}
        <button type="button" onclick="removeDateFromSelection('${dateStr}')" class="ml-1 text-indigo-500 hover:text-indigo-700" aria-label="Remove date">
          <span class="material-symbols-outlined" style="font-size: 0.875rem;">close</span>
        </button>
      </span>`;
    }).join('');
  }

  /**
   * Removes a date from selection
   */
  window.removeDateFromSelection = function(dateStr) {
    selectedDatesSet.delete(dateStr);
    renderCalendar();
    updateSelectedDatesDisplay();
    updateCustomDatesInput();
    updateSeriesPreview();
  };

  /**
   * Updates the hidden input field with selected dates
   */
  function updateCustomDatesInput() {
    const input = document.getElementById('customDates');
    if (input) {
      const sortedDates = Array.from(selectedDatesSet).sort();
      input.value = sortedDates.join('\n');
    }
  }

  /**
   * Updates custom dates from manual entry
   */
  window.updateCustomDatesFromManual = function() {
    const manualInput = document.getElementById('customDatesManual');
    if (!manualInput) return;

    const lines = manualInput.value.split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0)
      .filter(line => /^\d{4}-\d{2}-\d{2}$/.test(line));

    // Add valid dates to selection
    lines.forEach(dateStr => {
      selectedDatesSet.add(dateStr);
    });

    renderCalendar();
    updateSelectedDatesDisplay();
    updateCustomDatesInput();
    updateSeriesPreview();
  };

  /**
   * Updates the series preview based on selected pattern
   */
  window.updateSeriesPreview = function() {
    const pattern = document.getElementById('seriesPattern').value;
    const previewDiv = document.getElementById('seriesPreview');
    const previewList = document.getElementById('seriesPreviewList');
    const previewCount = document.getElementById('seriesPreviewCount');
    
    // Hide all pattern options first
    document.getElementById('weeklyOptions').classList.add('hidden');
    document.getElementById('monthlyOptions').classList.add('hidden');
    document.getElementById('customDatesOptions').classList.add('hidden');
    
    if (!pattern) {
      previewDiv.classList.add('hidden');
      return;
    }
    
    let dates = [];
    
    if (pattern === 'weekly') {
      document.getElementById('weeklyOptions').classList.remove('hidden');
      const startDate = document.getElementById('seriesStartDate').value;
      const occurrences = parseInt(document.getElementById('seriesOccurrences').value) || 4;
      
      if (startDate) {
        const start = new Date(startDate);
        for (let i = 0; i < occurrences; i++) {
          const date = new Date(start);
          date.setDate(start.getDate() + (i * 7));
          dates.push(date.toISOString().split('T')[0]);
        }
      }
    } else if (pattern === 'monthly') {
      document.getElementById('monthlyOptions').classList.remove('hidden');
      const startDate = document.getElementById('seriesStartDateMonthly').value;
      const occurrences = parseInt(document.getElementById('seriesOccurrencesMonthly').value) || 3;
      
      if (startDate) {
        const start = new Date(startDate);
        for (let i = 0; i < occurrences; i++) {
          const date = new Date(start);
          date.setMonth(start.getMonth() + i);
          dates.push(date.toISOString().split('T')[0]);
        }
      }
    } else if (pattern === 'custom') {
      document.getElementById('customDatesOptions').classList.remove('hidden');
      // Initialize calendar if not already done
      setTimeout(() => {
        if (document.getElementById('calendarGrid') && document.getElementById('calendarGrid').children.length <= 7) {
          initCalendarMultiPicker();
        }
      }, 50);
      
      const customDatesText = document.getElementById('customDates').value;
      if (customDatesText) {
        dates = customDatesText.split('\n')
          .map(line => line.trim())
          .filter(line => line.length > 0)
          .filter(line => /^\d{4}-\d{2}-\d{2}$/.test(line));
      }
    }
    
    if (dates.length > 0) {
      previewDiv.classList.remove('hidden');
      previewList.innerHTML = dates.map(date => {
        const dateObj = new Date(date);
        return `<div class="py-1 text-sm">${dateObj.toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' })}</div>`;
      }).join('');
      previewCount.textContent = `${dates.length} event${dates.length !== 1 ? 's' : ''} will be created`;
    } else {
      previewDiv.classList.add('hidden');
    }
  };

  /**
   * Opens the edit modal for a staged announcement
   * @param {string} announcementId - The ID of the announcement to edit
   */
  async function editStagedAnnouncement(announcementId) {
      currentEditId = announcementId;
      currentEditType = 'staged-announcement';
      
      // Find the announcement data from the already loaded announcements
      const response = await fetch('/api/admin/announcements-staged', { credentials: 'include' });
      const data = await response.json();
      const announcement = data.announcements.find(a => a.id === announcementId);
      
      if (announcement) {
        document.getElementById('editAnnouncementModalTitle').textContent = 'Edit Staged Announcement';
        document.getElementById('editAnnouncementTitle').value = announcement.title || '';
        document.getElementById('editAnnouncementMessage').value = announcement.message || '';
        document.getElementById('editAnnouncementLink').value = announcement.link || '';
        document.getElementById('editAnnouncementEmail').value = announcement.email || '';
        document.getElementById('editAnnouncementAuthor').value = announcement.author || '';
        
        if (announcement.show_at) {
          const showAt = new Date(announcement.show_at);
          document.getElementById('editAnnouncementShowAtDate').value = showAt.toISOString().split('T')[0];
          document.getElementById('editAnnouncementShowAtTime').value = showAt.toTimeString().substring(0, 5);
        } else {
          document.getElementById('editAnnouncementShowAtDate').value = '';
          document.getElementById('editAnnouncementShowAtTime').value = '';
        }
        
        if (announcement.expires_at) {
          const expiresAt = new Date(announcement.expires_at);
          document.getElementById('editAnnouncementExpiresAtDate').value = expiresAt.toISOString().split('T')[0];
          document.getElementById('editAnnouncementExpiresAtTime').value = expiresAt.toTimeString().substring(0, 5);
        } else {
          document.getElementById('editAnnouncementExpiresAtDate').value = '';
          document.getElementById('editAnnouncementExpiresAtTime').value = '';
        }
        
        // Handle organization (staged announcements use organization string, not ID)
        if (announcement.organization) {
          document.getElementById('editAnnouncementOrganizationSearch').value = announcement.organization;
        } else if (announcement.organization_id) {
          // Try to find organization name
          const org = allOrganizations.find(o => o.id === announcement.organization_id);
          if (org) {
            document.getElementById('editAnnouncementOrganizationSearch').value = org.name;
            document.getElementById('editAnnouncementOrganizationId').value = org.id;
          }
        }
        
        document.getElementById('editAnnouncementComments').value = announcement.comments || '';
        const modal = document.getElementById('editAnnouncementModal');
        if (modal) {
          modal.classList.remove('hidden');
          modal.classList.add('flex');
          window.scrollTo({ top: 0, behavior: 'smooth' });
          // Ensure autocomplete is set up when modal opens
          setTimeout(ensureAnnouncementAutocompleteSetup, 50);
        }
      } else {
        showMessage('Announcement not found', 'error');
      }
    }

  /**
   * Opens the edit modal for an existing (published) announcement
   * @param {string} announcementId - The ID of the announcement to edit
   */
  async function editExistingAnnouncement(announcementId) {
      currentEditId = announcementId;
      currentEditType = 'existing-announcement';
      
      // Try to find the announcement data from the already loaded announcements first
      let response = await fetch('/api/admin/announcements', { credentials: 'include' });
      let data = await response.json();
      let announcement = data.announcements && data.announcements.find(a => a.id === announcementId);
      
      // If not found, try fetching directly (might be a published/upcoming announcement)
      if (!announcement) {
        response = await fetch(`/api/admin/announcements/${announcementId}`, { credentials: 'include' });
        if (response.ok) {
          data = await response.json();
          announcement = data.announcement;
        }
      }
      
      if (announcement) {
        document.getElementById('editAnnouncementModalTitle').textContent = 'Edit Existing Announcement';
        document.getElementById('editAnnouncementTitle').value = announcement.title || '';
        document.getElementById('editAnnouncementMessage').value = announcement.message || '';
        document.getElementById('editAnnouncementLink').value = announcement.link || '';
        document.getElementById('editAnnouncementEmail').value = announcement.email || '';
        document.getElementById('editAnnouncementAuthor').value = announcement.author || '';
        
        if (announcement.show_at) {
          const showAt = new Date(announcement.show_at);
          document.getElementById('editAnnouncementShowAtDate').value = showAt.toISOString().split('T')[0];
          document.getElementById('editAnnouncementShowAtTime').value = showAt.toTimeString().substring(0, 5);
        } else {
          document.getElementById('editAnnouncementShowAtDate').value = '';
          document.getElementById('editAnnouncementShowAtTime').value = '';
        }
        
        if (announcement.expires_at) {
          const expiresAt = new Date(announcement.expires_at);
          document.getElementById('editAnnouncementExpiresAtDate').value = expiresAt.toISOString().split('T')[0];
          document.getElementById('editAnnouncementExpiresAtTime').value = expiresAt.toTimeString().substring(0, 5);
        } else {
          document.getElementById('editAnnouncementExpiresAtDate').value = '';
          document.getElementById('editAnnouncementExpiresAtTime').value = '';
        }
        
        // Handle organization
        if (announcement.organization_id) {
          const org = allOrganizations.find(o => o.id === announcement.organization_id);
          if (org) {
            document.getElementById('editAnnouncementOrganizationSearch').value = org.name;
            document.getElementById('editAnnouncementOrganizationId').value = org.id;
          }
        }
        
        document.getElementById('editAnnouncementComments').value = announcement.comments || '';
        const modal = document.getElementById('editAnnouncementModal');
        if (modal) {
          modal.classList.remove('hidden');
          modal.classList.add('flex');
          window.scrollTo({ top: 0, behavior: 'smooth' });
          // Ensure autocomplete is set up when modal opens
          setTimeout(ensureAnnouncementAutocompleteSetup, 50);
        }
      } else {
        showMessage('Announcement not found', 'error');
      }
    }

  /**
   * Approves an existing (non-staged) event by changing its status to 'approved'
   * @param {string} eventId - The ID of the event to approve
   */
  async function approveExistingEvent(eventId) {
      try {
        // First check if event has primary_tag
        const response = await fetch('/api/admin/events', { credentials: 'include' });
        const data = await response.json();
        const event = data.events.find(e => e.id === eventId);
        
        if (!event) {
          showMessage('Event not found', 'error');
          return;
        }
        
        if (!event.primary_tag_id) {
          showMessage('Event must have a primary tag selected before approval. Please edit the event first.', 'error');
          return;
        }
        
        const approveResponse = await fetch('/api/admin/events/approve', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ eventId }),
        });
        if (approveResponse.ok) {
          showMessage('Event approved successfully!', 'success');
          loadEventsToApprove();
        } else {
          const errorData = await approveResponse.json();
          throw new Error(errorData.error || 'Failed to approve event');
        }
      } catch (error) {
        showMessage('Error approving event: ' + error.message, 'error');
      }
    }

    async function approveExistingAnnouncement(announcementId) {
      try {
        const response = await fetch('/api/admin/announcements/approve', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ announcementId }),
        });
        if (response.ok) {
          showMessage('Announcement approved successfully!', 'success');
          loadAnnouncementsToApprove();
        } else {
          throw new Error('Failed to approve announcement');
        }
      } catch (error) {
        showMessage('Error approving announcement: ' + error.message, 'error');
      }
    }

    // Reject existing events/announcements
    async function rejectExistingEvent(eventId) {
      const reason = prompt('Reason for archiving (optional):');
      try {
        const response = await fetch('/api/admin/events/reject', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ eventId, reason }),
        });
        if (response.ok) {
          showMessage('Event archived successfully!', 'success');
          loadEventsToApprove();
        } else {
          throw new Error('Failed to archive event');
        }
      } catch (error) {
        showMessage('Error archiving event: ' + error.message, 'error');
      }
    }

    async function rejectExistingAnnouncement(announcementId) {
      const reason = prompt('Reason for archiving (optional):');
      try {
        const response = await fetch('/api/admin/announcements/reject', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ announcementId, reason }),
        });
        if (response.ok) {
          showMessage('Announcement archived successfully!', 'success');
          loadAnnouncementsToApprove();
        } else {
          throw new Error('Failed to archive announcement');
        }
      } catch (error) {
        showMessage('Error archiving announcement: ' + error.message, 'error');
      }
    }

    window.approveEvent = approveEvent;
    window.rejectEvent = rejectEvent;
    window.approveAnnouncement = approveAnnouncement;
    window.rejectAnnouncement = rejectAnnouncement;
    window.editStagedEvent = editStagedEvent;
    window.editExistingEvent = editExistingEvent;
    window.editStagedAnnouncement = editStagedAnnouncement;
    window.editExistingAnnouncement = editExistingAnnouncement;
    window.approveExistingEvent = approveExistingEvent;
    window.approveExistingAnnouncement = approveExistingAnnouncement;
    window.rejectExistingEvent = rejectExistingEvent;
    window.rejectExistingAnnouncement = rejectExistingAnnouncement;
    
    // Modal functions
  /**
   * Opens the announcement edit modal in "create new announcement" mode
   */
  window.openCreateAnnouncementModal = function() {
      currentEditId = null;
      currentEditType = 'new-announcement';
      
      // Clear all form fields
      document.getElementById('editAnnouncementModalTitle').textContent = 'Create New Announcement';
      document.getElementById('editAnnouncementTitle').value = '';
      document.getElementById('editAnnouncementMessage').value = '';
      document.getElementById('editAnnouncementShowAtDate').value = '';
      document.getElementById('editAnnouncementShowAtTime').value = '';
      document.getElementById('editAnnouncementExpiresAtDate').value = '';
      document.getElementById('editAnnouncementExpiresAtTime').value = '';
      document.getElementById('editAnnouncementLink').value = '';
      document.getElementById('editAnnouncementEmail').value = '';
      document.getElementById('editAnnouncementAuthor').value = '';
      document.getElementById('editAnnouncementOrganizationSearch').value = '';
      document.getElementById('editAnnouncementOrganizationId').value = '';
      document.getElementById('editAnnouncementOrganizationAdded').value = '';
      document.getElementById('editAnnouncementComments').value = '';
      
      // Show "add new" fields
      const orgContainer = document.getElementById('editAnnouncementOrganizationAddedContainer');
      if (orgContainer) orgContainer.classList.remove('hidden');
      
      // Open modal
      const modal = document.getElementById('editAnnouncementModal');
      if (modal) {
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        window.scrollTo({ top: 0, behavior: 'smooth' });
        // Ensure autocomplete is set up when modal opens
        setTimeout(ensureAnnouncementAutocompleteSetup, 50);
      }
    };

  /**
   * Opens the event edit modal in "create new event" mode
   */
  window.openCreateEventModal = function() {
      currentEditId = null;
      currentEditType = 'new-event';
      
      // Clear all form fields
      document.getElementById('editEventModalTitle').textContent = 'Create New Event';
      document.getElementById('editEventTitle').value = '';
      document.getElementById('editEventDescription').value = '';
      document.getElementById('editEventStartDate').value = '';
      document.getElementById('editEventEndDate').value = '';
      document.getElementById('editEventStartTime').value = '';
      document.getElementById('editEventEndTime').value = '';
      document.getElementById('editEventEmail').value = '';
      document.getElementById('editEventWebsite').value = '';
      document.getElementById('editEventRegistrationLink').value = '';
      document.getElementById('editEventExternalImageUrl').value = '';
      document.getElementById('editEventCost').value = '';
      document.getElementById('editEventPrimaryTag').value = '';
      document.getElementById('editEventSecondaryTag').value = '';
      document.getElementById('editEventLocationSearch').value = '';
      document.getElementById('editEventLocationId').value = '';
      document.getElementById('editEventOrganizationSearch').value = '';
      document.getElementById('editEventOrganizationId').value = '';
      document.getElementById('editEventParentEventSearch').value = '';
      document.getElementById('editEventParentEventId').value = '';
      document.getElementById('editEventComments').value = '';
      
      // Reset checkbox fields
      document.getElementById('editEventRegistration').checked = false;
      document.getElementById('editEventExcludeFromCalendar').checked = false;
      document.getElementById('editEventFeatured').checked = false;
      document.getElementById('editEventDraft').checked = false;
      document.getElementById('editEventCancelled').checked = false;
      syncEventStatusControls();
      
      // Open modal
      const modal = document.getElementById('editEventModal');
      if (modal) {
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        window.scrollTo({ top: 0, behavior: 'smooth' });
        // Ensure autocomplete is set up when modal opens
        setTimeout(ensureEventAutocompleteSetup, 50);
      }
    };
    
  // ============================================================================
  // MODAL MANAGEMENT FUNCTIONS
  // ============================================================================
  
  /**
   * Closes the event edit modal and resets state
   */
  window.closeEditEventModal = function() {
      const modal = document.getElementById('editEventModal');
      if (modal) {
        modal.classList.add('hidden');
        modal.classList.remove('flex');
      }
      currentEditId = null;
      currentEditType = null;
    };

  /**
   * Closes the announcement edit modal and resets state
   */
  window.closeEditAnnouncementModal = function() {
      const modal = document.getElementById('editAnnouncementModal');
      if (modal) {
        modal.classList.add('hidden');
        modal.classList.remove('flex');
      }
      currentEditId = null;
      currentEditType = null;
    };
    
    // Handle form submission
    // Event form submission handler
    const editEventForm = document.getElementById('editEventForm');
    if (editEventForm) {
      editEventForm.addEventListener('submit', async function(e) {
      e.preventDefault();
      
      if (!currentEditType) return;
      
      // Handle creating new event
      if (currentEditType === 'new-event') {
      const formData = {
          title: document.getElementById('editEventTitle').value,
          description: document.getElementById('editEventDescription').value,
          start_date: document.getElementById('editEventStartDate').value,
          end_date: document.getElementById('editEventEndDate').value || null,
          start_time: document.getElementById('editEventStartTime').value || null,
          end_time: document.getElementById('editEventEndTime').value || null,
          email: document.getElementById('editEventEmail').value || null,
          website: normalizeUrl(document.getElementById('editEventWebsite').value),
          registration_link: normalizeUrl(document.getElementById('editEventRegistrationLink').value),
          external_image_url: normalizeUrl(document.getElementById('editEventExternalImageUrl').value),
          cost: document.getElementById('editEventCost').value || null,
          primary_tag_id: document.getElementById('editEventPrimaryTag').value || null,
          secondary_tag_id: document.getElementById('editEventSecondaryTag').value || null,
          location_id: document.getElementById('editEventLocationId').value || null,
          organization_id: document.getElementById('editEventOrganizationId').value || null,
          parent_event_id: document.getElementById('editEventParentEventId').value || null,
          comments: document.getElementById('editEventComments').value || null,
          registration: document.getElementById('editEventRegistration').checked,
          exclude_from_calendar: document.getElementById('editEventExcludeFromCalendar').checked,
          featured: document.getElementById('editEventFeatured').checked,
          status: getEventStatusFromForm(),
        };
        
        // Validate required fields
        if (!formData.title || !formData.start_date) {
          showMessage('Title and start date are required', 'error');
          return;
        }
        
        if (!formData.primary_tag_id) {
          showMessage('Primary tag is required', 'error');
          return;
        }
        
        try {
          const response = await fetch('/api/admin/events/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify(formData),
          });
          
          if (response.ok) {
            const data = await response.json();
            showMessage('Event created successfully!', 'success');
            closeEditEventModal();
            // Reload all event lists
            await Promise.all([
              loadEventsToApprove(),
              loadIncompleteEvents()
            ]);
            // Redirect to event detail page if we have the ID
            if (data.event && data.event.id) {
              setTimeout(() => {
                window.location.href = `/events/${data.event.id}`;
              }, 500);
            }
          } else {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to create event');
          }
        } catch (error) {
          showMessage('Error creating event: ' + error.message, 'error');
        }
        return;
      }
      
      if (!currentEditId) return;
      
      let formData = {
        id: currentEditId,
        title: document.getElementById('editEventTitle').value,
      };
      
      // Event-specific fields
      formData.description = document.getElementById('editEventDescription').value;
      formData.email = document.getElementById('editEventEmail').value;
      formData.comments = document.getElementById('editEventComments').value;
      // Validate primary tag is selected
      const primaryTag = document.getElementById('editEventPrimaryTag').value;
      if (!primaryTag) {
        showMessage('Primary tag is required before saving', 'error');
        return;
      }
      
      formData.start_date = document.getElementById('editEventStartDate').value;
      formData.end_date = document.getElementById('editEventEndDate').value || null;
      formData.start_time = document.getElementById('editEventStartTime').value || null;
      formData.end_time = document.getElementById('editEventEndTime').value || null;
        formData.website = normalizeUrl(document.getElementById('editEventWebsite').value);
        formData.registration_link = normalizeUrl(document.getElementById('editEventRegistrationLink').value);
        formData.external_image_url = normalizeUrl(document.getElementById('editEventExternalImageUrl').value);
        formData.cost = document.getElementById('editEventCost').value || null;
      formData.primary_tag_id = primaryTag || null;
      formData.secondary_tag_id = document.getElementById('editEventSecondaryTag').value || null;
      formData.registration = document.getElementById('editEventRegistration').checked;
      formData.exclude_from_calendar = document.getElementById('editEventExcludeFromCalendar').checked;
      formData.featured = document.getElementById('editEventFeatured').checked;
      formData.status = getEventStatusFromForm();
      
      formData.location_id = document.getElementById('editEventLocationId').value || null;
      formData.organization_id = document.getElementById('editEventOrganizationId').value || null;
      
      // Handle parent event
      const parentEventId = document.getElementById('editEventParentEventId').value;
      formData.parent_event_id = parentEventId || null;
      
      try {
        let endpoint = '';
        let reloadFunction = null;
        
        switch (currentEditType) {
          case 'staged-event':
            endpoint = '/api/admin/events-staged/edit';
            reloadFunction = loadEventsToApprove;
            break;
          case 'existing-event':
            endpoint = '/api/admin/events';
            reloadFunction = loadEventsToApprove;
            break;
          case 'staged-announcement':
            endpoint = '/api/admin/announcements-staged/edit';
            reloadFunction = loadAnnouncementsToApprove;
            break;
          case 'existing-announcement':
            endpoint = '/api/admin/announcements';
            reloadFunction = () => {
              loadAnnouncementsToApprove();
              loadUpcomingAnnouncements();
            };
            break;
        }
        
        const response = await fetch(endpoint, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(formData)
        });
        
        if (response.ok) {
          showMessage('Updated successfully!', 'success');
          
          // Store values before closing modal (which might clear them)
          const editType = currentEditType;
          const editId = currentEditId;
          
          closeEditEventModal();
          
          // For events, redirect to the event detail page to see the changes
          if (editType && editType.includes('event') && editId) {
            // Small delay to show success message, then redirect
            setTimeout(() => {
              window.location.href = `/events/${editId}`;
            }, 500);
          } else {
            // For announcements, just reload the list
          if (reloadFunction) reloadFunction();
          }
        } else {
          const errorText = await response.text();
          console.error('Edit failed:', errorText);
          throw new Error('Failed to update: ' + errorText);
        }
      } catch (error) {
        console.error('Edit error:', error);
        showMessage('Error updating: ' + error.message, 'error');
      }
    });
    }

    // Announcement form submission handler
    const editAnnouncementForm = document.getElementById('editAnnouncementForm');
    if (editAnnouncementForm) {
      editAnnouncementForm.addEventListener('submit', async function(e) {
      e.preventDefault();
      
      if (!currentEditType) return;
      
      // Handle creating new announcement
      if (currentEditType === 'new-announcement') {
        const formData = {
          title: document.getElementById('editAnnouncementTitle').value,
          message: document.getElementById('editAnnouncementMessage').value,
          link: normalizeUrl(document.getElementById('editAnnouncementLink').value),
          email: document.getElementById('editAnnouncementEmail').value || null,
          author: document.getElementById('editAnnouncementAuthor').value || null,
          comments: document.getElementById('editAnnouncementComments').value || null,
        };
        
        // Handle show_at
        const showAtDate = document.getElementById('editAnnouncementShowAtDate').value;
        const showAtTime = document.getElementById('editAnnouncementShowAtTime').value;
        if (showAtDate && showAtTime) {
          formData.show_at = showAtDate + 'T' + showAtTime + ':00';
        } else if (showAtDate) {
          formData.show_at = showAtDate + 'T00:00:00';
        } else {
          formData.show_at = null;
        }
        
        // Handle expires_at
        const expiresAtDate = document.getElementById('editAnnouncementExpiresAtDate').value;
        const expiresAtTime = document.getElementById('editAnnouncementExpiresAtTime').value;
        if (expiresAtDate && expiresAtTime) {
          formData.expires_at = expiresAtDate + 'T' + expiresAtTime + ':00';
        } else if (expiresAtDate) {
          formData.expires_at = expiresAtDate + 'T23:59:59';
        } else {
          formData.expires_at = null;
        }
        
        // Handle organization - for new announcements, use organization_added if provided
        const orgId = document.getElementById('editAnnouncementOrganizationId').value;
        const orgAdded = document.getElementById('editAnnouncementOrganizationAdded').value.trim();
        
        if (orgId) {
          // Look up the organization name for staged announcements
          const org = allOrganizations.find(o => o.id === orgId);
          if (org) {
            formData.organization = org.name;
            formData.organization_added = null;
          }
        } else if (orgAdded) {
          formData.organization = null;
          formData.organization_added = orgAdded;
        }
        
        // Validate required fields
        if (!formData.title || !formData.message) {
          showMessage('Title and message are required', 'error');
          return;
        }
        
        try {
          // Create as staged announcement
          const response = await fetch('/api/admin/announcements-staged/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify(formData)
          });
          
          if (response.ok) {
            closeEditAnnouncementModal();
            showMessage('Announcement created successfully! It will appear in the approval queue.', 'success');
            if (typeof loadAnnouncementsToApprove === 'function') {
              loadAnnouncementsToApprove();
            }
          } else {
            const errorData = await response.json().catch(() => ({ error: 'Failed to create announcement' }));
            throw new Error(errorData.error || 'Failed to create announcement');
          }
        } catch (error) {
          console.error('Create error:', error);
          showMessage('Error creating announcement: ' + error.message, 'error');
        }
        return;
      }
      
      if (!currentEditId || !currentEditType || !currentEditType.includes('announcement')) return;
      
      let formData = {
        id: currentEditId,
        title: document.getElementById('editAnnouncementTitle').value,
        message: document.getElementById('editAnnouncementMessage').value,
        link: normalizeUrl(document.getElementById('editAnnouncementLink').value),
        email: document.getElementById('editAnnouncementEmail').value || null,
        author: document.getElementById('editAnnouncementAuthor').value || null,
        comments: document.getElementById('editAnnouncementComments').value || null,
      };
      
      // Handle show_at
      const showAtDate = document.getElementById('editAnnouncementShowAtDate').value;
      const showAtTime = document.getElementById('editAnnouncementShowAtTime').value;
      if (showAtDate && showAtTime) {
        formData.show_at = showAtDate + 'T' + showAtTime + ':00';
      } else if (showAtDate) {
        formData.show_at = showAtDate + 'T00:00:00';
      } else {
        formData.show_at = null;
      }
      
      // Handle expires_at
      const expiresAtDate = document.getElementById('editAnnouncementExpiresAtDate').value;
      const expiresAtTime = document.getElementById('editAnnouncementExpiresAtTime').value;
      if (expiresAtDate && expiresAtTime) {
        formData.expires_at = expiresAtDate + 'T' + expiresAtTime + ':00';
      } else if (expiresAtDate) {
        formData.expires_at = expiresAtDate + 'T23:59:59';
      } else {
        formData.expires_at = null;
      }
      
      // Handle organization - different for staged vs existing announcements
      const orgId = document.getElementById('editAnnouncementOrganizationId').value;
      const orgAdded = document.getElementById('editAnnouncementOrganizationAdded').value.trim();
      
      if (currentEditType === 'staged-announcement') {
        // Staged announcements use 'organization' (text) and 'organization_added' (text), not organization_id
        if (orgId) {
          // Look up the organization name
          const org = allOrganizations.find(o => o.id === orgId);
          if (org) {
            formData.organization = org.name;
            formData.organization_added = null;
          } else {
            formData.organization = null;
            formData.organization_added = null;
          }
        } else if (orgAdded) {
          formData.organization = null;
          formData.organization_added = orgAdded;
        } else {
          formData.organization = null;
          formData.organization_added = null;
        }
        // Don't include organization_id for staged announcements
        delete formData.organization_id;
      } else {
        // Existing announcements use organization_id (uuid)
        if (orgId) {
          formData.organization_id = orgId;
        } else {
          formData.organization_id = null;
        }
        // Don't include organization or organization_added for existing announcements
        delete formData.organization;
        delete formData.organization_added;
      }
      
      try {
        let endpoint = '';
        let reloadFunction = null;
        
        switch (currentEditType) {
          case 'staged-announcement':
            endpoint = '/api/admin/announcements-staged/edit';
            reloadFunction = loadAnnouncementsToApprove;
            break;
          case 'existing-announcement':
            endpoint = '/api/admin/announcements';
            reloadFunction = () => {
              loadAnnouncementsToApprove();
              loadUpcomingAnnouncements();
            };
            break;
        }
        
        const response = await fetch(endpoint, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(formData)
        });
        
        if (response.ok) {
          const savedEditType = currentEditType;
          const savedEditId = currentEditId;
          closeEditAnnouncementModal();
          showMessage('Announcement updated successfully!', 'success');
          
          // Reload the announcements lists
          if (reloadFunction) reloadFunction();
        } else {
          const errorText = await response.text();
          console.error('Edit failed:', errorText);
          throw new Error('Failed to update: ' + errorText);
        }
      } catch (error) {
        console.error('Edit error:', error);
        showMessage('Error updating: ' + error.message, 'error');
      }
      });
    }
    
    window.logout = async function() {
      try {
        const response = await fetch('/api/auth/logout', {
          method: 'POST',
          credentials: 'include',
        });
        if (response.ok) {
          window.location.href = '/';
        } else {
          // Even if logout fails, redirect to home
          window.location.href = '/';
        }
      } catch (error) {
        console.error('Logout error:', error);
        // Redirect anyway
        window.location.href = '/';
      }
    };

    // Series form submission handler
    const seriesForm = document.getElementById('seriesForm');
    if (seriesForm) {
      seriesForm.addEventListener('submit', async function(e) {
        e.preventDefault();
        
        const pattern = document.getElementById('seriesPattern').value;
        if (!pattern) {
          showMessage('Please select a pattern', 'error');
          return;
        }
        
        let dates = [];
        
        if (pattern === 'weekly') {
          const startDate = document.getElementById('seriesStartDate').value;
          const occurrences = parseInt(document.getElementById('seriesOccurrences').value) || 4;
          if (!startDate) {
            showMessage('Please select a start date', 'error');
            return;
          }
          const start = new Date(startDate);
          for (let i = 0; i < occurrences; i++) {
            const date = new Date(start);
            date.setDate(start.getDate() + (i * 7));
            dates.push(date.toISOString().split('T')[0]);
          }
        } else if (pattern === 'monthly') {
          const startDate = document.getElementById('seriesStartDateMonthly').value;
          const occurrences = parseInt(document.getElementById('seriesOccurrencesMonthly').value) || 3;
          if (!startDate) {
            showMessage('Please select a start date', 'error');
            return;
          }
          const start = new Date(startDate);
          for (let i = 0; i < occurrences; i++) {
            const date = new Date(start);
            date.setMonth(start.getMonth() + i);
            dates.push(date.toISOString().split('T')[0]);
          }
        } else if (pattern === 'custom') {
          // Get dates from calendar picker (selectedDatesSet) or manual input
          if (selectedDatesSet.size > 0) {
            // Use dates from calendar picker
            dates = Array.from(selectedDatesSet).sort();
          } else {
            // Fall back to manual input
            const customDatesText = document.getElementById('customDates').value;
            if (!customDatesText) {
              showMessage('Please select at least one date using the calendar or enter dates manually', 'error');
              return;
            }
            dates = customDatesText.split('\n')
              .map(line => line.trim())
              .filter(line => line.length > 0)
              .filter(line => /^\d{4}-\d{2}-\d{2}$/.test(line));
          }
          if (dates.length === 0) {
            showMessage('Please enter valid dates in YYYY-MM-DD format', 'error');
            return;
          }
        }
        
        if (dates.length === 0) {
          showMessage('No dates generated', 'error');
          return;
        }
        
        // Get common fields from form
        const eventTitle = document.getElementById('seriesEventTitle').value.trim();
        if (!eventTitle) {
          showMessage('Event title is required', 'error');
          return;
        }
        
        const description = document.getElementById('seriesDescription').value.trim() || null;
        const startTime = document.getElementById('seriesStartTime').value || null;
        const endTime = document.getElementById('seriesEndTime').value || null;
        const email = document.getElementById('seriesEmail').value.trim() || null;
        const website = document.getElementById('seriesWebsite').value.trim() || null;
        const registrationLink = document.getElementById('seriesRegistrationLink').value.trim() || null;
        const externalImageUrl = document.getElementById('seriesExternalImageUrl').value.trim() || null;
        const cost = document.getElementById('seriesCost').value.trim() || null;
        const primaryTagId = document.getElementById('seriesPrimaryTag').value || null;
        if (!primaryTagId) {
          showMessage('Primary tag is required', 'error');
          return;
        }
        const secondaryTagId = document.getElementById('seriesSecondaryTag').value || null;
        const locationId = document.getElementById('seriesLocationId').value || null;
        const organizationId = document.getElementById('seriesOrganizationId').value || null;
        const locationAdded = document.getElementById('seriesLocationAdded').value.trim() || null;
        const organizationAdded = document.getElementById('seriesOrganizationAdded').value.trim() || null;
        const registration = document.getElementById('seriesRegistration').checked;
        const excludeFromCalendar = document.getElementById('seriesExcludeFromCalendar').checked;
        const featured = document.getElementById('seriesFeatured').checked;
        const createParent = document.getElementById('seriesCreateParent').checked;
        const comments = document.getElementById('seriesComments').value.trim() || null;
        const saveAsDraft = document.getElementById('seriesSaveAsDraft').checked;
        
        // Determine parent event ID
        let parentEventId = seriesTemplateEvent?.parent_event_id || null;
        
        // Create parent event if requested and template doesn't have one
        if (createParent && !parentEventId) {
          try {
            // Create a basic parent event
            const parentEventData = {
              title: eventTitle + ' (Series)',
              description: description || `Parent event for ${eventTitle} series`,
              start_date: dates[0], // Use first date as placeholder
              primary_tag_id: primaryTagId,
              secondary_tag_id: secondaryTagId || null,
              location_id: locationId || null,
              organization_id: organizationId || null,
              status: 'approved', // Parent events are always approved
              exclude_from_calendar: true, // Parent events typically excluded from calendar
            };
            
            const parentResponse = await fetch('/api/admin/events/create', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify(parentEventData),
            });
            
            if (parentResponse.ok) {
              const parentData = await parentResponse.json();
              parentEventId = parentData.event.id;
              
              // If we're creating from an existing event, link the original event to the parent
              if (seriesOriginalEventId) {
                try {
                  const updateResponse = await fetch('/api/admin/events', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                      id: seriesOriginalEventId,
                      parent_event_id: parentEventId,
                    }),
                  });
                  
                  if (!updateResponse.ok) {
                    // Failed to link original event to parent, but continuing with series creation
                  }
                } catch (updateError) {
                  // Error linking original event to parent, but continuing
                  // Don't fail the whole operation if this update fails
                }
              }
            } else {
              const errorData = await parentResponse.json();
              throw new Error(errorData.error || 'Failed to create parent event');
            }
          } catch (error) {
            showMessage('Error creating parent event: ' + error.message, 'error');
            return;
          }
        }
        
        // Build events array from form values
        const events = dates.map(date => {
          const eventData = {
            title: eventTitle, // Already validated above
            description: description,
            start_date: date,
            end_date: null, // Series events typically don't have end dates, but could be added later
            start_time: startTime,
            end_time: endTime,
            email: email,
            website: website,
            registration_link: registrationLink,
            external_image_url: externalImageUrl,
            cost: cost,
            primary_tag_id: primaryTagId, // Already validated above
            secondary_tag_id: secondaryTagId || null,
            parent_event_id: parentEventId, // Use the parent event ID (either existing or newly created)
            registration: registration,
            exclude_from_calendar: excludeFromCalendar,
            featured: featured,
            status: saveAsDraft ? 'pending' : 'approved', // Use draft checkbox
            comments: comments,
            location_id: locationId || null,
            organization_id: organizationId || null,
          };
          
          return eventData;
        });
        
        try {
          const response = await fetch('/api/admin/events/bulk-create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({
              events,
              location_added: locationAdded,
              organization_added: organizationAdded,
            }),
          });
          
          if (response.ok) {
            const data = await response.json();
            showMessage(`Successfully created ${data.count || events.length} event${events.length !== 1 ? 's' : ''}!`, 'success');
            closeSeriesModal();
            // Reload events
            await Promise.all([
              loadEventsToApprove(),
              loadIncompleteEvents()
            ]);
          } else {
            const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
            const errorMessage = errorData.error || errorData.details || 'Failed to create events';
            console.error('Bulk create error:', errorData);
            throw new Error(errorMessage);
          }
        } catch (error) {
          console.error('Error creating series:', error);
          showMessage('Error creating series: ' + (error.message || 'Unknown error'), 'error');
        }
      });
    }
  });
</script>
</body>
</html>
